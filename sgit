#!/usr/bin/env bash
# This script was generated by bashly 0.7.8 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :script.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n"
  exit 1
fi

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
sgit_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit - Syntactic sugar for Git, respecting semantics and modern conventions\n"
    echo

  else
    printf "sgit - Syntactic sugar for Git, respecting semantics and modern conventions\n"
    echo

  fi

  printf "Usage:\n"
  printf "  sgit [command]\n"
  printf "  sgit [command] --help | -h\n"
  printf "  sgit --version | -v\n"
  echo
  # :command.usage_commands
  printf "Branches Commands:\n"
  echo "  ls            List all branches, only remote or only local"
  echo "  take          Create new branch"
  echo "  cd            Change the current working branch"
  echo "  mv            Rename some branch"
  echo "  rm            Delete some branch"
  printf "\nState Commands:\n"
  echo "  save          Save credentials storage in git repository"
  echo "  wipe          Wipe the working branch as per the remote branch"
  echo "  rollback      Back the commit history, but it preserves the file contents"
  echo "  edit          Edit some commit message"
  echo "  get           Fetch and merge changes from remote branch to working branch (pull shortcut)"
  echo "  put           Send committed changes from working branch to the respective remote branch (push shortcut)"
  printf "\nConsult Commands:\n"
  echo "  log           Search in the history commit by applying some filters"
  echo "  status        Show the current state of git working directory and staging area"
  printf "\nStaging Commands:\n"
  echo "  add           Add files or directories to staging area"
  echo "  sub           Remove files or directories from staging area"
  echo "  amend         Add all untracked, modified and deleted files to the last commit without edit the message"
  echo "  tag           Add an annotated tag with the description same as the message"
  printf "\nCommit Commands:\n"
  echo "  build         Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)"
  echo "  chore         Code change that external user won't see (eg: change to .gitignore file or .prettierrc file)"
  echo "  ci            Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs)"
  echo "  docs          Documentation only changes"
  echo "  feat          New feature"
  echo "  fix           Bug fix"
  echo "  localize      Translations update"
  echo "  perf          Code change that improves performance"
  echo "  refactor      Code change that neither fixes a bug nor adds a feature; refactoring production code, eg. renaming a variable"
  echo "  revert        Reverts a previous commit"
  echo "  style         Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)"
  echo "  test          Adding missing tests or correcting existing tests"
  printf "\nCompletions Commands:\n"
  echo "  completions   Generate bash completions"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
sgit_ls_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit ls - List all branches, only remote or only local\n"
    echo

  else
    printf "sgit ls - List all branches, only remote or only local\n"
    echo

  fi

  printf "Usage:\n"
  printf "  sgit ls [options]\n"
  printf "  sgit ls --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --remote, -r"
    printf "    List only remote branches\n"
    echo

    # :flag.usage
    echo "  --local, -l"
    printf "    List only local branches\n"
    echo

  fi
}

# :command.usage
sgit_take_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit take - Create new branch\n"
    echo

  else
    printf "sgit take - Create new branch\n"
    echo

  fi

  printf "Shortcut: mkdir\n"
  echo

  printf "Usage:\n"
  printf "  sgit take [DESCRIPTION] [options]\n"
  printf "  sgit take --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --origin, -o"
    printf "    Defines if the branch should also be created in the origin\n"
    echo

    # :flag.usage
    echo "  --only-origin, -O"
    printf "    Defines if the branch should be only created in the origin\n"
    echo

    # :flag.usage
    echo "  --main"
    printf "    The production branch\n"
    echo

    # :flag.usage
    echo "  --staging, -s"
    printf "    Demo branch and decisions about release features\n"
    echo

    # :flag.usage
    echo "  --test, -t"
    printf "    Contains all codes ready for QA testing\n"
    echo

    # :flag.usage
    echo "  --dev, -d"
    printf "    All new features and bug fixes; codes conflicts should be done here\n"
    echo

    # :flag.usage
    echo "  --feature, -f DESCRIPTION"
    printf "    Any code changes for a new module or use case; should be created based on\n    the current development branch\n"
    echo

    # :flag.usage
    echo "  --bugfix, -b DESCRIPTION"
    printf "    If the code changes made from the feature branch were rejected after a\n    release, sprint or demo\n"
    echo

    # :flag.usage
    echo "  --hotfix, -H DESCRIPTION"
    printf "    If there is a need to fix something that should be handled immediately;\n    could be merged directly to the production branch\n"
    echo

    # :flag.usage
    echo "  --experimental, -e DESCRIPTION"
    printf "    Any new feature or idea that is not part of a release or a sprint; a branch\n    for playing around\n"
    echo

    # :flag.usage
    echo "  --build, -b DESCRIPTION"
    printf "    A branch specifically for creating specific build artifacts or for doing\n    code coverage runs\n"
    echo

    # :flag.usage
    echo "  --release, -r DESCRIPTION"
    printf "    A branch for tagging a specific release version\n"
    echo

    # :flag.usage
    echo "  --merge, -m DESCRIPTION"
    printf "    Resolving merge conflicts, usually between the latest development and a\n    feature or hotfix branch; also to merge two branches of one feature\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DESCRIPTION"
    printf "    The description is a brief explanation about the branch purpose\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  [Command]\n"
    printf "  - sgit take -f \"my really awesome feature\" -o\n"
    printf "  [Result]\n"
    printf "  - git checkout -b \"feature/my-really-awesome-feature\"\n"
    printf "  - git push origin \"feature/my-really-awesome-feature\"\n"
    echo

  fi
}

# :command.usage
sgit_cd_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit cd - Change the current working branch\n"
    echo

  else
    printf "sgit cd - Change the current working branch\n"
    echo

  fi

  printf "Usage:\n"
  printf "  sgit cd BRANCH\n"
  printf "  sgit cd --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  BRANCH"
    printf "    The branch to go to\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  [Command]\n"
    printf "  - sgit cd main\n"
    printf "  [Result]\n"
    printf "  - git checkout \"main\"\n"
    echo

  fi
}

# :command.usage
sgit_mv_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit mv - Rename some branch\n"
    echo

  else
    printf "sgit mv - Rename some branch\n"
    echo

  fi

  printf "Usage:\n"
  printf "  sgit mv OLD_BRANCH NEW_BRANCH [options]\n"
  printf "  sgit mv --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --origin, -o"
    printf "    Defines if the branch should also be renamed in the origin\n"
    echo

    # :flag.usage
    echo "  --only-origin, -O"
    printf "    Defines if the branch should be only renamed in the origin\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  OLD_BRANCH"
    printf "    The current branch you want to rename\n"
    echo

    # :argument.usage
    echo "  NEW_BRANCH"
    printf "    The new name for branch\n"
    echo

  fi
}

# :command.usage
sgit_rm_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit rm - Delete some branch\n"
    echo

  else
    printf "sgit rm - Delete some branch\n"
    echo

  fi

  printf "Usage:\n"
  printf "  sgit rm [BRANCH] [options]\n"
  printf "  sgit rm --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --origin, -o"
    printf "    Defines if the branch should also be deleted in the origin\n"
    echo

    # :flag.usage
    echo "  --only-origin, -O"
    printf "    Defines if the branch should be only deleted in the origin\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  BRANCH"
    printf "    Branch to delete; if none are informed, delete the current one\n"
    echo

  fi
}

# :command.usage
sgit_save_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit save - Save credentials storage in git repository\n"
    echo

  else
    printf "sgit save - Save credentials storage in git repository\n"
    echo

  fi

  printf "Usage:\n"
  printf "  sgit save [options]\n"
  printf "  sgit save --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --global, -g"
    printf "    Enable credentials storage globally\n"
    echo

  fi
}

# :command.usage
sgit_wipe_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit wipe - Wipe the working branch as per the remote branch\n"
    echo

  else
    printf "sgit wipe - Wipe the working branch as per the remote branch\n"
    echo

  fi

  printf "Usage:\n"
  printf "  sgit wipe [BRANCH] [options]\n"
  printf "  sgit wipe --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --yes, -y"
    printf "    Skip confirmation\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  BRANCH"
    printf "    Branch to wipe; if none are informed, wipe the current one\n"
    echo

  fi
}

# :command.usage
sgit_rollback_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit rollback - Back the commit history, but it preserves the file contents\n"
    echo

  else
    printf "sgit rollback - Back the commit history, but it preserves the file contents\n"
    echo

  fi

  printf "Shortcut: rb\n"
  echo

  printf "Usage:\n"
  printf "  sgit rollback [COMMIT_ID]\n"
  printf "  sgit rollback --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  COMMIT_ID"
    printf "    The commit ID; if none are informed, rollback to the last commit\n"
    echo

  fi
}

# :command.usage
sgit_edit_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit edit - Edit some commit message\n"
    echo

  else
    printf "sgit edit - Edit some commit message\n"
    echo

  fi

  printf "Usage:\n"
  printf "  sgit edit [COMMIT_ID]\n"
  printf "  sgit edit --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  COMMIT_ID"
    printf "    The commit ID; if none are informed, edit the last commit\n"
    echo

  fi
}

# :command.usage
sgit_get_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit get - Fetch and merge changes from remote branch to working branch (pull shortcut)\n"
    echo

  else
    printf "sgit get - Fetch and merge changes from remote branch to working branch (pull shortcut)\n"
    echo

  fi

  printf "Usage:\n"
  printf "  sgit get [BRANCH] [options]\n"
  printf "  sgit get --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --force, -f"
    printf "    Overwrite existing local commits in case conflicts\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  BRANCH"
    printf "    Branch name to get\n"
    echo

  fi
}

# :command.usage
sgit_put_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit put - Send committed changes from working branch to the respective remote branch (push shortcut)\n"
    echo

  else
    printf "sgit put - Send committed changes from working branch to the respective remote branch (push shortcut)\n"
    echo

  fi

  printf "Usage:\n"
  printf "  sgit put [BRANCH] [options]\n"
  printf "  sgit put --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --force, -f"
    printf "    Overwrite existing origin commits in case conflicts\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  BRANCH"
    printf "    Branch name to put\n"
    echo

  fi
}

# :command.usage
sgit_log_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit log - Search in the history commit by applying some filters\n"
    echo

  else
    printf "sgit log - Search in the history commit by applying some filters\n"
    echo

  fi

  printf "Shortcut: l\n"
  echo

  printf "Usage:\n"
  printf "  sgit log [SEARCH_TERMS] [options]\n"
  printf "  sgit log --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --author, -a AUTHOR"
    printf "    Filter by author\n"
    echo

    # :flag.usage
    echo "  --since, -s SINCE"
    printf "    Filter since of...\n"
    echo

    # :flag.usage
    echo "  --until, -u UNTIL"
    printf "    Filter until of...\n"
    echo

    # :flag.usage
    echo "  --exclude, -e"
    printf "    Filter excluding some term\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  SEARCH_TERMS"
    printf "    Type something to search, like \"feat\" to see all feature commits\n"
    echo

  fi
}

# :command.usage
sgit_status_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit status - Show the current state of git working directory and staging area\n"
    echo

  else
    printf "sgit status - Show the current state of git working directory and staging area\n"
    echo

  fi

  printf "Shortcut: s\n"
  echo

  printf "Usage:\n"
  printf "  sgit status\n"
  printf "  sgit status --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_add_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit add - Add files or directories to staging area\n"
    echo

  else
    printf "sgit add - Add files or directories to staging area\n"
    echo

  fi

  printf "Usage:\n"
  printf "  sgit add [STRING...]\n"
  printf "  sgit add --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_sub_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit sub - Remove files or directories from staging area\n"
    echo

  else
    printf "sgit sub - Remove files or directories from staging area\n"
    echo

  fi

  printf "Usage:\n"
  printf "  sgit sub [options] [STRING...]\n"
  printf "  sgit sub --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --all, -a"
    printf "    Remove all files or directories from staging area\n"
    echo

  fi
}

# :command.usage
sgit_amend_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit amend - Add all untracked, modified and deleted files to the last commit without edit the message\n"
    echo

  else
    printf "sgit amend - Add all untracked, modified and deleted files to the last commit without edit the message\n"
    echo

  fi

  printf "Usage:\n"
  printf "  sgit amend\n"
  printf "  sgit amend --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_tag_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit tag - Add an annotated tag with the description same as the message\n"
    echo

  else
    printf "sgit tag - Add an annotated tag with the description same as the message\n"
    echo

  fi

  printf "Shortcut: t\n"
  echo

  printf "Usage:\n"
  printf "  sgit tag [MESSAGE]\n"
  printf "  sgit tag --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  MESSAGE"
    printf "    The annotated/message\n"
    echo

  fi
}

# :command.usage
sgit_build_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit build - Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)\n"
    echo

  else
    printf "sgit build - Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)\n"
    echo

  fi

  printf "Shortcut: bd\n"
  echo

  printf "Usage:\n"
  printf "  sgit build [DESCRIPTION] [options]\n"
  printf "  sgit build --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    echo "  --breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    echo "  --edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    echo "  --add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    echo "  --add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    echo "  --put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    echo "  --force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  [Command]\n"
    printf "  - sgit build \"add express types\" -a package.json\n"
    printf "  [Result]\n"
    printf "  - git add package.json\n"
    printf "  - git commit -m \"build: add express types\"\n"
    echo

  fi
}

# :command.usage
sgit_chore_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit chore - Code change that external user won't see (eg: change to .gitignore file or .prettierrc file)\n"
    echo

  else
    printf "sgit chore - Code change that external user won't see (eg: change to .gitignore file or .prettierrc file)\n"
    echo

  fi

  printf "Shortcut: ch\n"
  echo

  printf "Usage:\n"
  printf "  sgit chore [DESCRIPTION] [options]\n"
  printf "  sgit chore --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    echo "  --breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    echo "  --edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    echo "  --add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    echo "  --add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    echo "  --put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    echo "  --force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  [Command]\n"
    printf "  - sgit chore -s \"router\" \"allow to extend other configs\" -A\n"
    printf "  [Result]\n"
    printf "  - git add .\n"
    printf "  - git commit -m \"chore(router): update public api\"\n"
    echo

  fi
}

# :command.usage
sgit_ci_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit ci - Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs)\n"
    echo

  else
    printf "sgit ci - Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs)\n"
    echo

  fi

  printf "Usage:\n"
  printf "  sgit ci [DESCRIPTION] [options]\n"
  printf "  sgit ci --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    echo "  --breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    echo "  --edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    echo "  --add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    echo "  --add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    echo "  --put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    echo "  --force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  [Command]\n"
    printf "  - sgit ci\n"
    printf "  [Result]\n"
    printf "  - git commit -m \"ci: \" --edit\n"
    printf "  - * Open default editor to complete the message *\n"
    echo

  fi
}

# :command.usage
sgit_docs_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit docs - Documentation only changes\n"
    echo

  else
    printf "sgit docs - Documentation only changes\n"
    echo

  fi

  printf "Shortcut: dc\n"
  echo

  printf "Usage:\n"
  printf "  sgit docs [DESCRIPTION] [options]\n"
  printf "  sgit docs --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    echo "  --breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    echo "  --edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    echo "  --add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    echo "  --add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    echo "  --put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    echo "  --force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  [Command]\n"
    printf "  - sgit docs \"update per tech review\" -Apfe\n"
    printf "  [Result]\n"
    printf "  - git add .\n"
    printf "  - git commit -m \"docs: update per tech review\" --edit\n"
    printf "  - * Open default editor to complete the message *\n"
    printf "  - git push --force\n"
    echo

  fi
}

# :command.usage
sgit_feat_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit feat - New feature\n"
    echo

  else
    printf "sgit feat - New feature\n"
    echo

  fi

  printf "Shortcut: ft\n"
  echo

  printf "Usage:\n"
  printf "  sgit feat [DESCRIPTION] [options]\n"
  printf "  sgit feat --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    echo "  --breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    echo "  --edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    echo "  --add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    echo "  --add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    echo "  --put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    echo "  --force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  [Command]\n"
    printf "  - sgit feat -s \"service-worker\" \"expose more version update events\" -bea \"-p\n  src/index.ts\"\n"
    printf "  [Result]\n"
    printf "  - git add -p src/index.ts\n"
    printf "  - git commit -m \"feat(service-worker)!: expose more version update events\"\n  --edit\n"
    printf "  - * Open default editor to complete the message *\n"
    echo

  fi
}

# :command.usage
sgit_fix_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit fix - Bug fix\n"
    echo

  else
    printf "sgit fix - Bug fix\n"
    echo

  fi

  printf "Usage:\n"
  printf "  sgit fix [DESCRIPTION] [options]\n"
  printf "  sgit fix --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    echo "  --breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    echo "  --edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    echo "  --add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    echo "  --add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    echo "  --put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    echo "  --force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  [Command]\n"
    printf "  - sgit fix \"clear service worker cache in safety worker\" -Aps \"service-worker\"\n"
    printf "  [Result]\n"
    printf "  - git add .\n"
    printf "  - git commit -m \"fix(service-worker): clear service worker cache in safety\n  worker\"\n"
    printf "  - git push\n"
    echo

  fi
}

# :command.usage
sgit_localize_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit localize - Translations update\n"
    echo

  else
    printf "sgit localize - Translations update\n"
    echo

  fi

  printf "Shortcut: lc\n"
  echo

  printf "Usage:\n"
  printf "  sgit localize [DESCRIPTION] [options]\n"
  printf "  sgit localize --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    echo "  --breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    echo "  --edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    echo "  --add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    echo "  --add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    echo "  --put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    echo "  --force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  [Command]\n"
    printf "  - sgit localize \"add new en_US terms\" --add-all\n"
    printf "  [Result]\n"
    printf "  - git add .\n"
    printf "  - git commit -m \"localize: add new us_en terms\"\n"
    echo

  fi
}

# :command.usage
sgit_perf_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit perf - Code change that improves performance\n"
    echo

  else
    printf "sgit perf - Code change that improves performance\n"
    echo

  fi

  printf "Shortcut: pf\n"
  echo

  printf "Usage:\n"
  printf "  sgit perf [DESCRIPTION] [options]\n"
  printf "  sgit perf --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    echo "  --breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    echo "  --edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    echo "  --add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    echo "  --add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    echo "  --put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    echo "  --force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  [Command]\n"
    printf "  - sgit perf \"add js-web-frameworks benchmark (#34034)\" -pa\n  \"/benchmarks/BUILD.bazel /benchmarks/perf.spec.ts\"\n"
    printf "  [Result]\n"
    printf "  - git add /benchmarks/BUILD.bazel /benchmarks/perf.spec.ts\n"
    printf "  - git commit -m \"perf: add js-web-frameworks benchmark (#34034)\"\n"
    printf "  - git push\n"
    echo

  fi
}

# :command.usage
sgit_refactor_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit refactor - Code change that neither fixes a bug nor adds a feature; refactoring production code, eg. renaming a variable\n"
    echo

  else
    printf "sgit refactor - Code change that neither fixes a bug nor adds a feature; refactoring production code, eg. renaming a variable\n"
    echo

  fi

  printf "Shortcut: rf\n"
  echo

  printf "Usage:\n"
  printf "  sgit refactor [DESCRIPTION] [options]\n"
  printf "  sgit refactor --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    echo "  --breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    echo "  --edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    echo "  --add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    echo "  --add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    echo "  --put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    echo "  --force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  [Command]\n"
    printf "  - sgit refactor \"allow to extend other configs\" -A\n"
    printf "  [Result]\n"
    printf "  - git add .\n"
    printf "  - git commit -m \"refactor: remove Éµloc and related code\"\n"
    echo

  fi
}

# :command.usage
sgit_revert_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit revert - Reverts a previous commit\n"
    echo

  else
    printf "sgit revert - Reverts a previous commit\n"
    echo

  fi

  printf "Shortcut: rv\n"
  echo

  printf "Usage:\n"
  printf "  sgit revert [DESCRIPTION] [options]\n"
  printf "  sgit revert --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    echo "  --breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    echo "  --edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    echo "  --add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    echo "  --add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    echo "  --put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    echo "  --force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  [Command]\n"
    printf "  - sgit revert \"`refactor(router): clean up internal hooks (#43804)` (#43845)\"\n"
    printf "  [Result]\n"
    printf "  - git commit -m \"revert: `refactor(router): clean up internal hooks (#43804)`\n  (#43845)\"\n"
    echo

  fi
}

# :command.usage
sgit_style_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit style - Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)\n"
    echo

  else
    printf "sgit style - Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)\n"
    echo

  fi

  printf "Shortcut: st\n"
  echo

  printf "Usage:\n"
  printf "  sgit style [DESCRIPTION] [options]\n"
  printf "  sgit style --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    echo "  --breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    echo "  --edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    echo "  --add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    echo "  --add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    echo "  --put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    echo "  --force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  [Command]\n"
    printf "  - sgit style \"lint panel component\" -p\n"
    printf "  [Result]\n"
    printf "  - git commit -m \"style: lint panel component\"\n"
    printf "  - git push\n"
    echo

  fi
}

# :command.usage
sgit_test_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit test - Adding missing tests or correcting existing tests\n"
    echo

  else
    printf "sgit test - Adding missing tests or correcting existing tests\n"
    echo

  fi

  printf "Shortcut: ts\n"
  echo

  printf "Usage:\n"
  printf "  sgit test [DESCRIPTION] [options]\n"
  printf "  sgit test --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    echo "  --breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    echo "  --edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    echo "  --add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    echo "  --add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    echo "  --put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    echo "  --force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  [Command]\n"
    printf "  - sgit test \"remove `document-register-element` from elements tests\" -Ap\n"
    printf "  [Result]\n"
    printf "  - git add .\n"
    printf "  - git commit -m \"test: remove `document-register-element` from elements tests\"\n"
    printf "  - git push\n"
    echo

  fi
}

# :command.usage
sgit_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit completions\n"
    echo

    printf "  Generate bash completions\n  Usage: eval \"\$(cli completions)\"\n"
    echo

  else
    printf "sgit completions - Generate bash completions\n"
    echo

  fi

  printf "Usage:\n"
  printf "  sgit completions\n"
  printf "  sgit completions --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# :src/lib/send_completions.sh
# [@bashly-upgrade completions send_completions]
send_completions() {
  echo $'#!/usr/bin/env bash'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $'_sgit_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local comp_line="${COMP_WORDS[*]:1}"'
  echo $''
  echo $'  case "$comp_line" in'
  echo $'    \'completions\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'rollback\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'localize\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'refactor\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'revert\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'status\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'mkdir\'*) COMPREPLY=($(compgen -W "--bugfix --build --dev --experimental --feature --help --hotfix --main --merge --only-origin --origin --release --staging --test -H -O -b -d -e -f -h -m -o -r -s -t" -- "$cur")) ;;'
  echo $'    \'style\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'amend\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'chore\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'build\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'docs\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'perf\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'feat\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'wipe\'*) COMPREPLY=($(compgen -W "$(git branch 2> /dev/null) --help --yes -h -y" -- "$cur")) ;;'
  echo $'    \'save\'*) COMPREPLY=($(compgen -W "--global --help -g -h" -- "$cur")) ;;'
  echo $'    \'test\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'edit\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'log\'*) COMPREPLY=($(compgen -W "--author --exclude --help --since --until -a -e -h -s -u" -- "$cur")) ;;'
  echo $'    \'add\'*) COMPREPLY=($(compgen -A directory -A file -W "--help -h" -- "$cur")) ;;'
  echo $'    \'tag\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'put\'*) COMPREPLY=($(compgen -W "$(git branch 2> /dev/null) --force --help -f -h" -- "$cur")) ;;'
  echo $'    \'get\'*) COMPREPLY=($(compgen -W "$(git branch 2> /dev/null) --force --help -f -h" -- "$cur")) ;;'
  echo $'    \'fix\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'sub\'*) COMPREPLY=($(compgen -A directory -A file -W "--all --help -a -h" -- "$cur")) ;;'
  echo $'    \'ci\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'rm\'*) COMPREPLY=($(compgen -W "$(git branch 2> /dev/null) --help --only-origin --origin -O -h -o" -- "$cur")) ;;'
  echo $'    \'mv\'*) COMPREPLY=($(compgen -W "$(git branch 2> /dev/null) --help --only-origin --origin -O -h -o" -- "$cur")) ;;'
  echo $'    \'ls\'*) COMPREPLY=($(compgen -W "--help --local --remote -h -l -r" -- "$cur")) ;;'
  echo $'    \'cd\'*) COMPREPLY=($(compgen -W "$(git branch 2> /dev/null) --help -h" -- "$cur")) ;;'
  echo $'    \'\'*) COMPREPLY=($(compgen -W "--help --version -h -v add amend build cd chore ci completions docs edit feat fix get localize log ls mkdir mv perf put refactor revert rm rollback save status style sub tag test wipe" -- "$cur")) ;;'
  echo $'  esac'
  echo $'}'
  echo $''
  echo $'complete -F _sgit_completions sgit'
}

# :command.command_functions
# :command.function
sgit_ls_command() {
  # :src/ls_command.sh
  if [ ! -z ${args[--local]} ]; then
    git branch -l | grep -v âremotesâ
  elif [ ! -z ${args[--remote]} ]; then
    git branch -r | grep -v âremotesâ
  else
    git branch -a | grep -v âremotesâ
  fi
}

# :command.function
sgit_take_command() {
  # :src/take_command.sh
  if [ ! -z "${args['description']}" ]; then
    branch=${args['description']}
  elif [ ! -z "${args['--main']}" ]; then
    branch=main
  elif [ ! -z "${args['--staging']}" ]; then
    branch=staged
  elif [ ! -z "${args['--test']}" ]; then
    branch=test
  elif [ ! -z "${args['--dev']}" ]; then
    branch=develop
  elif [ ! -z "${args['--feature']}" ]; then
    branch=feature/${args['--feature']}
  elif [ ! -z "${args['--bugfix']}" ]; then
    branch=bugfix/${args['--bugfix']}
  elif [ ! -z "${args['--hotfix']}" ]; then
    branch=hotfix/${args['--hotfix']}
  elif [ ! -z "${args['--experimental']}" ]; then
    branch=experimental/${args['--experimental']}
  elif [ ! -z "${args['--build']}" ]; then
    branch=build/${args['--build']}
  elif [ ! -z "${args['--release']}" ]; then
    branch=release/${args['--release']}
  elif [ ! -z "${args['--merge']}" ]; then
    branch=merge/${args['--merge']}
  fi

  branch=${branch// /-}

  if [ ! -z ${args['--only-origin']} ]; then
    git push -u origin $branch
  elif [ ! -z ${args['--origin']} ]; then
    git checkout -b $branch
    git push -u origin $branch
  else
    git checkout -b $branch
  fi
}

# :command.function
sgit_cd_command() {
  # :src/cd_command.sh
  git checkout ${args[branch]}
}

# :command.function
sgit_mv_command() {
  # :src/mv_command.sh
  if [ ! -z ${args[--only-origin]} ]; then
    git push origin origin/${args[old_branch]}:refs/heads/${args[new_branch]} :${args[old_branch]}
  elif [ ! -z ${args[--origin]} ]; then
    git branch -m ${args[old_branch]} ${args[new_branch]}
    git push origin origin/${args[old_branch]}:refs/heads/${args[new_branch]} :${args[old_branch]}
  else
    git branch -m ${args[old_branch]} ${args[new_branch]}
  fi
}

# :command.function
sgit_rm_command() {
  # :src/rm_command.sh
  if [ ! -z ${args[--only-origin]} ]; then
    git push origin --delete ${args[branch]}
  else
    if [ ${args[branch]} == "$(git branch --show-current)" ]; then
      branches=$(git branch -l)
      IFS=$'\n'
      branches=($branches)
      current_branch=$(git rev-parse --abbrev-ref HEAD)
      jump_branch=$([[ "*$current_branch" == "${branches[0]// /}" ]] && echo "${branches[1]// /}" || echo "${branches[0]// /}")
      git checkout $jump_branch
    fi
    git branch -D ${args[branch]}
    if [ ! -z ${args[--origin]} ]; then
      git push origin --delete ${args[branch]}
    fi
  fi
}

# :command.function
sgit_save_command() {
  # :src/save_command.sh
  if [ ! -z ${args[--global]} ]; then
    git config --global credential.helper store
  else
    git config credential.helper store
  fi
}

# :command.function
sgit_wipe_command() {
  # :src/wipe_command.sh
  branch=$([[ ! -z "${args[branch]}" ]] && echo ${args[branch]} || echo $(git rev-parse --abbrev-ref HEAD))

  if [ ! -z ${args[--yes]} ]; then
    git reset --hard origin/$branch
  else
    echo "Are you sure you want to wipe (hard reset) \"$branch\" branch? (y/N)"
    read REPLY
    if [[ "$REPLY" =~ ^[Yy]$ ]]; then
      git reset --hard origin/$branch
    fi
  fi
}

# :command.function
sgit_rollback_command() {
  # :src/rollback_command.sh
  if [ ! -z ${args[commit_id]} ]; then
    git reset --soft ${args[commit_id]}
  else
    git reset --soft HEAD~1
  fi
  git reset
}

# :command.function
sgit_edit_command() {
  # :src/edit_command.sh
  if [ -z ${args[commit_id]} ]; then
    git commit --amend
  else
    HEAD_COMMIT=$(git rev-list HEAD | nl | grep ${args[commit_id]})
    read HEAD_ID _ <<<"$HEAD_COMMIT"

    echo "==========================="
    echo
    echo "ATTENTION! Alter \"pick\" to \"reword\" in the commit you want to edit."
    echo "After that, save and close the file, so you will be able to edit the commit message."
    echo ""
    echo "To publish you must run \"git put --force\"."
    echo "This is NOT RECOMMENDED if commits have already been made to a remote repository and other collaborators are active."
    echo
    echo "==========================="

    git rebase -i HEAD~$HEAD_ID

  fi
}

# :command.function
sgit_get_command() {
  # :src/get_command.sh
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")
  branch=$([[ ! -z "${args[branch]}" ]] && echo ${args[branch]} || echo $(git rev-parse --abbrev-ref HEAD))

  git pull $force origin $branch
}

# :command.function
sgit_put_command() {
  # :src/put_command.sh
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")
  branch=$([[ ! -z "${args[branch]}" ]] && echo ${args[branch]} || echo $(git rev-parse --abbrev-ref HEAD))

  git push $force origin $branch
}

# :command.function
sgit_log_command() {
  # :src/log_command.sh
  query+=$([[ ! -z "${args[search_terms]}" ]] && echo "--grep ${args[search_terms]} " || echo "")
  query+=$([[ ! -z "${args[--author]}" ]] && echo "--author ${args[--author]} " || echo "")
  query+=$([[ ! -z "${args[--since]}" ]] && echo "--since ${args[--since]} " || echo "")
  query+=$([[ ! -z "${args[--until]}" ]] && echo "--until ${args[--until]} " || echo "")
  query+=$([[ ! -z "${args[--exclude]}" ]] && echo "--invert-grep " || echo "")

  git log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %C(green)(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit $query
}

# :command.function
sgit_status_command() {
  # :src/status_command.sh
  git status -s
}

# :command.function
sgit_add_command() {
  # :src/add_command.sh
  git add ${other_args[*]}
}

# :command.function
sgit_sub_command() {
  # :src/sub_command.sh
  if [ ! -z "${args[--all]}" ]; then
    git reset
  else
    git restore --staged ${other_args[*]}
  fi
}

# :command.function
sgit_amend_command() {
  # :src/amend_command.sh
  git add . --all
  git commit --amend --no-edit
}

# :command.function
sgit_tag_command() {
  # :src/tag_command.sh
  git config --global push.followTags true
  git tag -a ${args[message]} -m ${args[message]}
}

# :command.function
sgit_build_command() {
  # :src/build_command.sh
  type=build
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add .
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi
}

# :command.function
sgit_chore_command() {
  # :src/chore_command.sh
  type=chore
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add .
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi
}

# :command.function
sgit_ci_command() {
  # :src/ci_command.sh
  type=ci
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add .
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi
}

# :command.function
sgit_docs_command() {
  # :src/docs_command.sh
  type=docs
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add .
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi
}

# :command.function
sgit_feat_command() {
  # :src/feat_command.sh
  type=feat
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add .
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi
}

# :command.function
sgit_fix_command() {
  # :src/fix_command.sh
  type=fix
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add .
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi
}

# :command.function
sgit_localize_command() {
  # :src/localize_command.sh
  type=localize
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add .
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi
}

# :command.function
sgit_perf_command() {
  # :src/perf_command.sh
  type=perf
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add .
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi
}

# :command.function
sgit_refactor_command() {
  # :src/refactor_command.sh
  type=refactor
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add .
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi
}

# :command.function
sgit_revert_command() {
  # :src/revert_command.sh
  type=revert
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add .
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi
}

# :command.function
sgit_style_command() {
  # :src/style_command.sh
  type=style
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add .
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi
}

# :command.function
sgit_test_command() {
  # :src/test_command.sh
  type=test
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add .
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi
}

# :command.function
sgit_completions_command() {
  # :src/completions_command.sh
  # Call the `send_completions` function which was added by running:
  #
  #   $ bashly add comp function
  #
  # Users can now enable bash completion for this script by running:
  #
  #   $ eval "$(sgit completions)"
  #
  send_completions
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --version | -v )
    version_command
    exit
    ;;

  --help | -h )
    long_usage=yes
    sgit_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  ls )
    action="ls"
    shift
    sgit_ls_parse_requirements "$@"
    shift $#
    ;;

  take | mkdir )
    action="take"
    shift
    sgit_take_parse_requirements "$@"
    shift $#
    ;;

  cd )
    action="cd"
    shift
    sgit_cd_parse_requirements "$@"
    shift $#
    ;;

  mv )
    action="mv"
    shift
    sgit_mv_parse_requirements "$@"
    shift $#
    ;;

  rm )
    action="rm"
    shift
    sgit_rm_parse_requirements "$@"
    shift $#
    ;;

  save )
    action="save"
    shift
    sgit_save_parse_requirements "$@"
    shift $#
    ;;

  wipe )
    action="wipe"
    shift
    sgit_wipe_parse_requirements "$@"
    shift $#
    ;;

  rollback | rb )
    action="rollback"
    shift
    sgit_rollback_parse_requirements "$@"
    shift $#
    ;;

  edit )
    action="edit"
    shift
    sgit_edit_parse_requirements "$@"
    shift $#
    ;;

  get )
    action="get"
    shift
    sgit_get_parse_requirements "$@"
    shift $#
    ;;

  put )
    action="put"
    shift
    sgit_put_parse_requirements "$@"
    shift $#
    ;;

  log | l )
    action="log"
    shift
    sgit_log_parse_requirements "$@"
    shift $#
    ;;

  status | s )
    action="status"
    shift
    sgit_status_parse_requirements "$@"
    shift $#
    ;;

  add )
    action="add"
    shift
    sgit_add_parse_requirements "$@"
    shift $#
    ;;

  sub )
    action="sub"
    shift
    sgit_sub_parse_requirements "$@"
    shift $#
    ;;

  amend )
    action="amend"
    shift
    sgit_amend_parse_requirements "$@"
    shift $#
    ;;

  tag | t )
    action="tag"
    shift
    sgit_tag_parse_requirements "$@"
    shift $#
    ;;

  build | bd )
    action="build"
    shift
    sgit_build_parse_requirements "$@"
    shift $#
    ;;

  chore | ch )
    action="chore"
    shift
    sgit_chore_parse_requirements "$@"
    shift $#
    ;;

  ci )
    action="ci"
    shift
    sgit_ci_parse_requirements "$@"
    shift $#
    ;;

  docs | dc )
    action="docs"
    shift
    sgit_docs_parse_requirements "$@"
    shift $#
    ;;

  feat | ft )
    action="feat"
    shift
    sgit_feat_parse_requirements "$@"
    shift $#
    ;;

  fix )
    action="fix"
    shift
    sgit_fix_parse_requirements "$@"
    shift $#
    ;;

  localize | lc )
    action="localize"
    shift
    sgit_localize_parse_requirements "$@"
    shift $#
    ;;

  perf | pf )
    action="perf"
    shift
    sgit_perf_parse_requirements "$@"
    shift $#
    ;;

  refactor | rf )
    action="refactor"
    shift
    sgit_refactor_parse_requirements "$@"
    shift $#
    ;;

  revert | rv )
    action="revert"
    shift
    sgit_revert_parse_requirements "$@"
    shift $#
    ;;

  style | st )
    action="style"
    shift
    sgit_style_parse_requirements "$@"
    shift $#
    ;;

  test | ts )
    action="test"
    shift
    sgit_test_parse_requirements "$@"
    shift $#
    ;;

  completions )
    action="completions"
    shift
    sgit_completions_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  * )
    sgit_usage
    exit 1
    ;;

  esac
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_ls_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_ls_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="ls"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --remote | -r )
      # :flag.conflicts
      args[--remote]=1
      shift
      ;;

    # :flag.case
    --local | -l )
      # :flag.conflicts
      args[--local]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_take_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_take_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="take"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --origin | -o )
      # :flag.conflicts
      args[--origin]=1
      shift
      ;;

    # :flag.case
    --only-origin | -O )
      # :flag.conflicts
      args[--only-origin]=1
      shift
      ;;

    # :flag.case
    --main )
      # :flag.conflicts
      args[--main]=1
      shift
      ;;

    # :flag.case
    --staging | -s )
      # :flag.conflicts
      args[--staging]=1
      shift
      ;;

    # :flag.case
    --test | -t )
      # :flag.conflicts
      args[--test]=1
      shift
      ;;

    # :flag.case
    --dev | -d )
      # :flag.conflicts
      args[--dev]=1
      shift
      ;;

    # :flag.case
    --feature | -f )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--feature]="$2"
        shift
        shift
      else
        printf "%s\n" "--feature requires an argument: --feature, -f DESCRIPTION"
        exit 1
      fi
      ;;

    # :flag.case
    --bugfix | -b )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--bugfix]="$2"
        shift
        shift
      else
        printf "%s\n" "--bugfix requires an argument: --bugfix, -b DESCRIPTION"
        exit 1
      fi
      ;;

    # :flag.case
    --hotfix | -H )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--hotfix]="$2"
        shift
        shift
      else
        printf "%s\n" "--hotfix requires an argument: --hotfix, -H DESCRIPTION"
        exit 1
      fi
      ;;

    # :flag.case
    --experimental | -e )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--experimental]="$2"
        shift
        shift
      else
        printf "%s\n" "--experimental requires an argument: --experimental, -e DESCRIPTION"
        exit 1
      fi
      ;;

    # :flag.case
    --build | -b )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--build]="$2"
        shift
        shift
      else
        printf "%s\n" "--build requires an argument: --build, -b DESCRIPTION"
        exit 1
      fi
      ;;

    # :flag.case
    --release | -r )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--release]="$2"
        shift
        shift
      else
        printf "%s\n" "--release requires an argument: --release, -r DESCRIPTION"
        exit 1
      fi
      ;;

    # :flag.case
    --merge | -m )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--merge]="$2"
        shift
        shift
      else
        printf "%s\n" "--merge requires an argument: --merge, -m DESCRIPTION"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[description]+x} ]]; then
        # :argument.validations
        args[description]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_cd_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_cd_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="cd"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[branch]+x} ]]; then
        # :argument.validations
        args[branch]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[branch]+x} ]]; then
    printf "missing required argument: BRANCH\nusage: sgit cd BRANCH\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_mv_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_mv_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="mv"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --origin | -o )
      # :flag.conflicts
      args[--origin]=1
      shift
      ;;

    # :flag.case
    --only-origin | -O )
      # :flag.conflicts
      args[--only-origin]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[old_branch]+x} ]]; then
        # :argument.validations
        args[old_branch]=$1
        shift
      elif [[ -z ${args[new_branch]+x} ]]; then
        # :argument.validations
        args[new_branch]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[old_branch]+x} ]]; then
    printf "missing required argument: OLD_BRANCH\nusage: sgit mv OLD_BRANCH NEW_BRANCH [options]\n"
    exit 1
  fi
  if [[ -z ${args[new_branch]+x} ]]; then
    printf "missing required argument: NEW_BRANCH\nusage: sgit mv OLD_BRANCH NEW_BRANCH [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_rm_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_rm_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="rm"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --origin | -o )
      # :flag.conflicts
      args[--origin]=1
      shift
      ;;

    # :flag.case
    --only-origin | -O )
      # :flag.conflicts
      args[--only-origin]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[branch]+x} ]]; then
        # :argument.validations
        args[branch]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_save_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_save_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="save"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --global | -g )
      # :flag.conflicts
      args[--global]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_wipe_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_wipe_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="wipe"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --yes | -y )
      # :flag.conflicts
      args[--yes]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[branch]+x} ]]; then
        # :argument.validations
        args[branch]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_rollback_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_rollback_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="rollback"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[commit_id]+x} ]]; then
        # :argument.validations
        args[commit_id]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_edit_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_edit_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="edit"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[commit_id]+x} ]]; then
        # :argument.validations
        args[commit_id]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_get_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_get_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="get"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[branch]+x} ]]; then
        # :argument.validations
        args[branch]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_put_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_put_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="put"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[branch]+x} ]]; then
        # :argument.validations
        args[branch]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_log_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_log_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="log"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --author | -a )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--author]="$2"
        shift
        shift
      else
        printf "%s\n" "--author requires an argument: --author, -a AUTHOR"
        exit 1
      fi
      ;;

    # :flag.case
    --since | -s )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--since]="$2"
        shift
        shift
      else
        printf "%s\n" "--since requires an argument: --since, -s SINCE"
        exit 1
      fi
      ;;

    # :flag.case
    --until | -u )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--until]="$2"
        shift
        shift
      else
        printf "%s\n" "--until requires an argument: --until, -u UNTIL"
        exit 1
      fi
      ;;

    # :flag.case
    --exclude | -e )
      # :flag.conflicts
      args[--exclude]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[search_terms]+x} ]]; then
        # :argument.validations
        args[search_terms]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_status_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_status_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="status"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_add_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_add_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="add"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      other_args+=("$1")
      shift
      ;;

    * )
      # :command.parse_requirements_case
        other_args+=("$1")
        shift
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_sub_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_sub_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="sub"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --all | -a )
      # :flag.conflicts
      args[--all]=1
      shift
      ;;

    -?* )
      other_args+=("$1")
      shift
      ;;

    * )
      # :command.parse_requirements_case
        other_args+=("$1")
        shift
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_amend_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_amend_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="amend"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_tag_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_tag_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="tag"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[message]+x} ]]; then
        # :argument.validations
        args[message]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_build_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_build_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="build"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --scope | -s )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--scope]="$2"
        shift
        shift
      else
        printf "%s\n" "--scope requires an argument: --scope, -s SCOPE"
        exit 1
      fi
      ;;

    # :flag.case
    --breaking-change | -b )
      # :flag.conflicts
      args[--breaking-change]=1
      shift
      ;;

    # :flag.case
    --edit | -e )
      # :flag.conflicts
      args[--edit]=1
      shift
      ;;

    # :flag.case
    --add | -a )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--add]="$2"
        shift
        shift
      else
        printf "%s\n" "--add requires an argument: --add, -a ADD"
        exit 1
      fi
      ;;

    # :flag.case
    --add-all | -A )
      # :flag.conflicts
      args[--add-all]=1
      shift
      ;;

    # :flag.case
    --put | -p )
      # :flag.conflicts
      args[--put]=1
      shift
      ;;

    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[description]+x} ]]; then
        # :argument.validations
        args[description]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_chore_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_chore_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="chore"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --scope | -s )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--scope]="$2"
        shift
        shift
      else
        printf "%s\n" "--scope requires an argument: --scope, -s SCOPE"
        exit 1
      fi
      ;;

    # :flag.case
    --breaking-change | -b )
      # :flag.conflicts
      args[--breaking-change]=1
      shift
      ;;

    # :flag.case
    --edit | -e )
      # :flag.conflicts
      args[--edit]=1
      shift
      ;;

    # :flag.case
    --add | -a )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--add]="$2"
        shift
        shift
      else
        printf "%s\n" "--add requires an argument: --add, -a ADD"
        exit 1
      fi
      ;;

    # :flag.case
    --add-all | -A )
      # :flag.conflicts
      args[--add-all]=1
      shift
      ;;

    # :flag.case
    --put | -p )
      # :flag.conflicts
      args[--put]=1
      shift
      ;;

    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[description]+x} ]]; then
        # :argument.validations
        args[description]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_ci_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_ci_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="ci"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --scope | -s )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--scope]="$2"
        shift
        shift
      else
        printf "%s\n" "--scope requires an argument: --scope, -s SCOPE"
        exit 1
      fi
      ;;

    # :flag.case
    --breaking-change | -b )
      # :flag.conflicts
      args[--breaking-change]=1
      shift
      ;;

    # :flag.case
    --edit | -e )
      # :flag.conflicts
      args[--edit]=1
      shift
      ;;

    # :flag.case
    --add | -a )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--add]="$2"
        shift
        shift
      else
        printf "%s\n" "--add requires an argument: --add, -a ADD"
        exit 1
      fi
      ;;

    # :flag.case
    --add-all | -A )
      # :flag.conflicts
      args[--add-all]=1
      shift
      ;;

    # :flag.case
    --put | -p )
      # :flag.conflicts
      args[--put]=1
      shift
      ;;

    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[description]+x} ]]; then
        # :argument.validations
        args[description]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_docs_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_docs_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="docs"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --scope | -s )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--scope]="$2"
        shift
        shift
      else
        printf "%s\n" "--scope requires an argument: --scope, -s SCOPE"
        exit 1
      fi
      ;;

    # :flag.case
    --breaking-change | -b )
      # :flag.conflicts
      args[--breaking-change]=1
      shift
      ;;

    # :flag.case
    --edit | -e )
      # :flag.conflicts
      args[--edit]=1
      shift
      ;;

    # :flag.case
    --add | -a )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--add]="$2"
        shift
        shift
      else
        printf "%s\n" "--add requires an argument: --add, -a ADD"
        exit 1
      fi
      ;;

    # :flag.case
    --add-all | -A )
      # :flag.conflicts
      args[--add-all]=1
      shift
      ;;

    # :flag.case
    --put | -p )
      # :flag.conflicts
      args[--put]=1
      shift
      ;;

    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[description]+x} ]]; then
        # :argument.validations
        args[description]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_feat_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_feat_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="feat"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --scope | -s )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--scope]="$2"
        shift
        shift
      else
        printf "%s\n" "--scope requires an argument: --scope, -s SCOPE"
        exit 1
      fi
      ;;

    # :flag.case
    --breaking-change | -b )
      # :flag.conflicts
      args[--breaking-change]=1
      shift
      ;;

    # :flag.case
    --edit | -e )
      # :flag.conflicts
      args[--edit]=1
      shift
      ;;

    # :flag.case
    --add | -a )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--add]="$2"
        shift
        shift
      else
        printf "%s\n" "--add requires an argument: --add, -a ADD"
        exit 1
      fi
      ;;

    # :flag.case
    --add-all | -A )
      # :flag.conflicts
      args[--add-all]=1
      shift
      ;;

    # :flag.case
    --put | -p )
      # :flag.conflicts
      args[--put]=1
      shift
      ;;

    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[description]+x} ]]; then
        # :argument.validations
        args[description]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_fix_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_fix_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="fix"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --scope | -s )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--scope]="$2"
        shift
        shift
      else
        printf "%s\n" "--scope requires an argument: --scope, -s SCOPE"
        exit 1
      fi
      ;;

    # :flag.case
    --breaking-change | -b )
      # :flag.conflicts
      args[--breaking-change]=1
      shift
      ;;

    # :flag.case
    --edit | -e )
      # :flag.conflicts
      args[--edit]=1
      shift
      ;;

    # :flag.case
    --add | -a )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--add]="$2"
        shift
        shift
      else
        printf "%s\n" "--add requires an argument: --add, -a ADD"
        exit 1
      fi
      ;;

    # :flag.case
    --add-all | -A )
      # :flag.conflicts
      args[--add-all]=1
      shift
      ;;

    # :flag.case
    --put | -p )
      # :flag.conflicts
      args[--put]=1
      shift
      ;;

    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[description]+x} ]]; then
        # :argument.validations
        args[description]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_localize_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_localize_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="localize"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --scope | -s )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--scope]="$2"
        shift
        shift
      else
        printf "%s\n" "--scope requires an argument: --scope, -s SCOPE"
        exit 1
      fi
      ;;

    # :flag.case
    --breaking-change | -b )
      # :flag.conflicts
      args[--breaking-change]=1
      shift
      ;;

    # :flag.case
    --edit | -e )
      # :flag.conflicts
      args[--edit]=1
      shift
      ;;

    # :flag.case
    --add | -a )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--add]="$2"
        shift
        shift
      else
        printf "%s\n" "--add requires an argument: --add, -a ADD"
        exit 1
      fi
      ;;

    # :flag.case
    --add-all | -A )
      # :flag.conflicts
      args[--add-all]=1
      shift
      ;;

    # :flag.case
    --put | -p )
      # :flag.conflicts
      args[--put]=1
      shift
      ;;

    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[description]+x} ]]; then
        # :argument.validations
        args[description]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_perf_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_perf_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="perf"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --scope | -s )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--scope]="$2"
        shift
        shift
      else
        printf "%s\n" "--scope requires an argument: --scope, -s SCOPE"
        exit 1
      fi
      ;;

    # :flag.case
    --breaking-change | -b )
      # :flag.conflicts
      args[--breaking-change]=1
      shift
      ;;

    # :flag.case
    --edit | -e )
      # :flag.conflicts
      args[--edit]=1
      shift
      ;;

    # :flag.case
    --add | -a )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--add]="$2"
        shift
        shift
      else
        printf "%s\n" "--add requires an argument: --add, -a ADD"
        exit 1
      fi
      ;;

    # :flag.case
    --add-all | -A )
      # :flag.conflicts
      args[--add-all]=1
      shift
      ;;

    # :flag.case
    --put | -p )
      # :flag.conflicts
      args[--put]=1
      shift
      ;;

    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[description]+x} ]]; then
        # :argument.validations
        args[description]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_refactor_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_refactor_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="refactor"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --scope | -s )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--scope]="$2"
        shift
        shift
      else
        printf "%s\n" "--scope requires an argument: --scope, -s SCOPE"
        exit 1
      fi
      ;;

    # :flag.case
    --breaking-change | -b )
      # :flag.conflicts
      args[--breaking-change]=1
      shift
      ;;

    # :flag.case
    --edit | -e )
      # :flag.conflicts
      args[--edit]=1
      shift
      ;;

    # :flag.case
    --add | -a )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--add]="$2"
        shift
        shift
      else
        printf "%s\n" "--add requires an argument: --add, -a ADD"
        exit 1
      fi
      ;;

    # :flag.case
    --add-all | -A )
      # :flag.conflicts
      args[--add-all]=1
      shift
      ;;

    # :flag.case
    --put | -p )
      # :flag.conflicts
      args[--put]=1
      shift
      ;;

    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[description]+x} ]]; then
        # :argument.validations
        args[description]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_revert_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_revert_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="revert"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --scope | -s )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--scope]="$2"
        shift
        shift
      else
        printf "%s\n" "--scope requires an argument: --scope, -s SCOPE"
        exit 1
      fi
      ;;

    # :flag.case
    --breaking-change | -b )
      # :flag.conflicts
      args[--breaking-change]=1
      shift
      ;;

    # :flag.case
    --edit | -e )
      # :flag.conflicts
      args[--edit]=1
      shift
      ;;

    # :flag.case
    --add | -a )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--add]="$2"
        shift
        shift
      else
        printf "%s\n" "--add requires an argument: --add, -a ADD"
        exit 1
      fi
      ;;

    # :flag.case
    --add-all | -A )
      # :flag.conflicts
      args[--add-all]=1
      shift
      ;;

    # :flag.case
    --put | -p )
      # :flag.conflicts
      args[--put]=1
      shift
      ;;

    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[description]+x} ]]; then
        # :argument.validations
        args[description]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_style_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_style_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="style"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --scope | -s )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--scope]="$2"
        shift
        shift
      else
        printf "%s\n" "--scope requires an argument: --scope, -s SCOPE"
        exit 1
      fi
      ;;

    # :flag.case
    --breaking-change | -b )
      # :flag.conflicts
      args[--breaking-change]=1
      shift
      ;;

    # :flag.case
    --edit | -e )
      # :flag.conflicts
      args[--edit]=1
      shift
      ;;

    # :flag.case
    --add | -a )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--add]="$2"
        shift
        shift
      else
        printf "%s\n" "--add requires an argument: --add, -a ADD"
        exit 1
      fi
      ;;

    # :flag.case
    --add-all | -A )
      # :flag.conflicts
      args[--add-all]=1
      shift
      ;;

    # :flag.case
    --put | -p )
      # :flag.conflicts
      args[--put]=1
      shift
      ;;

    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[description]+x} ]]; then
        # :argument.validations
        args[description]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_test_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_test_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="test"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --scope | -s )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--scope]="$2"
        shift
        shift
      else
        printf "%s\n" "--scope requires an argument: --scope, -s SCOPE"
        exit 1
      fi
      ;;

    # :flag.case
    --breaking-change | -b )
      # :flag.conflicts
      args[--breaking-change]=1
      shift
      ;;

    # :flag.case
    --edit | -e )
      # :flag.conflicts
      args[--edit]=1
      shift
      ;;

    # :flag.case
    --add | -a )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--add]="$2"
        shift
        shift
      else
        printf "%s\n" "--add requires an argument: --add, -a ADD"
        exit 1
      fi
      ;;

    # :flag.case
    --add-all | -A )
      # :flag.conflicts
      args[--add-all]=1
      shift
      ;;

    # :flag.case
    --put | -p )
      # :flag.conflicts
      args[--put]=1
      shift
      ;;

    # :flag.case
    --force | -f )
      # :flag.conflicts
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[description]+x} ]]; then
        # :argument.validations
        args[description]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
sgit_completions_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    sgit_completions_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="completions"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.initialize
initialize() {
  version="0.2.0"
  long_usage=''
  set -e

  # :src/initialize.sh
  # Code here runs inside the initialize() function
  # Use it for anything that you need to run before any other function, like
  # setting environment vairables:
  # CONFIG_FILE=settings.ini
  #
  # Feel free to empty (but not delete) this file.
}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "ls" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_ls_usage
    else
      sgit_ls_command
    fi

  elif [[ $action == "take" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_take_usage
    else
      sgit_take_command
    fi

  elif [[ $action == "cd" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_cd_usage
    else
      sgit_cd_command
    fi

  elif [[ $action == "mv" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_mv_usage
    else
      sgit_mv_command
    fi

  elif [[ $action == "rm" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_rm_usage
    else
      sgit_rm_command
    fi

  elif [[ $action == "save" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_save_usage
    else
      sgit_save_command
    fi

  elif [[ $action == "wipe" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_wipe_usage
    else
      sgit_wipe_command
    fi

  elif [[ $action == "rollback" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_rollback_usage
    else
      sgit_rollback_command
    fi

  elif [[ $action == "edit" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_edit_usage
    else
      sgit_edit_command
    fi

  elif [[ $action == "get" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_get_usage
    else
      sgit_get_command
    fi

  elif [[ $action == "put" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_put_usage
    else
      sgit_put_command
    fi

  elif [[ $action == "log" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_log_usage
    else
      sgit_log_command
    fi

  elif [[ $action == "status" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_status_usage
    else
      sgit_status_command
    fi

  elif [[ $action == "add" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_add_usage
    else
      sgit_add_command
    fi

  elif [[ $action == "sub" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_sub_usage
    else
      sgit_sub_command
    fi

  elif [[ $action == "amend" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_amend_usage
    else
      sgit_amend_command
    fi

  elif [[ $action == "tag" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_tag_usage
    else
      sgit_tag_command
    fi

  elif [[ $action == "build" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_build_usage
    else
      sgit_build_command
    fi

  elif [[ $action == "chore" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_chore_usage
    else
      sgit_chore_command
    fi

  elif [[ $action == "ci" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_ci_usage
    else
      sgit_ci_command
    fi

  elif [[ $action == "docs" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_docs_usage
    else
      sgit_docs_command
    fi

  elif [[ $action == "feat" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_feat_usage
    else
      sgit_feat_command
    fi

  elif [[ $action == "fix" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_fix_usage
    else
      sgit_fix_command
    fi

  elif [[ $action == "localize" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_localize_usage
    else
      sgit_localize_command
    fi

  elif [[ $action == "perf" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_perf_usage
    else
      sgit_perf_command
    fi

  elif [[ $action == "refactor" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_refactor_usage
    else
      sgit_refactor_command
    fi

  elif [[ $action == "revert" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_revert_usage
    else
      sgit_revert_command
    fi

  elif [[ $action == "style" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_style_usage
    else
      sgit_style_command
    fi

  elif [[ $action == "test" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_test_usage
    else
      sgit_test_command
    fi

  elif [[ $action == "completions" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      sgit_completions_usage
    else
      sgit_completions_command
    fi

  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
