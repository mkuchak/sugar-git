#!/usr/bin/env bash
# This script was generated by bashly 1.1.3 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
sgit_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit - Syntactic sugar for Git, respecting semantics and modern conventions\n"
    echo

  else
    printf "sgit - Syntactic sugar for Git, respecting semantics and modern conventions\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  sgit COMMAND\n"
  printf "  sgit [COMMAND] --help | -h\n"
  printf "  sgit --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Branches Commands:"
  printf "  %s   List all branches, only remote or only local\n" "ls         "
  printf "  %s   Create new branch\n" "take       "
  printf "  %s   Change the current working branch\n" "cd         "
  printf "  %s   Rename some branch\n" "mv         "
  printf "  %s   Delete some branch\n" "rm         "
  echo
  printf "%s\n" "State Commands:"
  printf "  %s   Save credentials storage in git repository\n" "save       "
  printf "  %s   Show the current remote repository\n" "remote     "
  printf "  %s   Wipe the working branch as per the remote branch\n" "wipe       "
  printf "  %s   Back the commit history, but it preserves the file contents\n" "rollback   "
  printf "  %s   Edit some commit message\n" "edit       "
  printf "  %s   Fetch and merge changes from remote branch to working branch (pull shortcut)\n" "get        "
  printf "  %s   Send committed changes from working branch to the respective remote branch (push shortcut)\n" "put        "
  echo
  printf "%s\n" "Consult Commands:"
  printf "  %s   Search in the history commit by applying some filters\n" "log        "
  printf "  %s   Show the current state of git working directory and staging area\n" "status     "
  printf "  %s   Show the incoming commits from remote branch that is not in the working branch\n" "incoming   "
  printf "  %s   Show the outgoing commits from working branch that is not in the remote branch\n" "outgoing   "
  printf "  %s   Show the committers of the current branch\n" "committers "
  echo
  printf "%s\n" "Staging Commands:"
  printf "  %s   Add files or directories to staging area\n" "add        "
  printf "  %s   Remove files or directories from staging area\n" "sub        "
  printf "  %s   Add all untracked, modified and deleted files to the last commit without edit the message\n" "amend      "
  printf "  %s   Resolve conflicts in the working branch\n" "resolve    "
  printf "  %s   Add an annotated tag with the description same as the message\n" "tag        "
  echo
  printf "%s\n" "Commit Commands:"
  printf "  %s   Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)\n" "build      "
  printf "  %s   Code change that external user won't see (eg: change to .gitignore file or .prettierrc file)\n" "chore      "
  printf "  %s   Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs)\n" "ci         "
  printf "  %s   Documentation only changes\n" "docs       "
  printf "  %s   New feature\n" "feat       "
  printf "  %s   Bug fix\n" "fix        "
  printf "  %s   Translations update\n" "localize   "
  printf "  %s   Code change that improves performance\n" "perf       "
  printf "  %s   Code change that neither fixes a bug nor adds a feature; refactoring production code, eg. renaming a variable\n" "refactor   "
  printf "  %s   Reverts a previous commit\n" "revert     "
  printf "  %s   Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)\n" "style      "
  printf "  %s   Adding missing tests or correcting existing tests\n" "test       "
  echo
  printf "%s\n" "Completions Commands:"
  printf "  %s   Generate bash completions\n" "completions"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
sgit_ls_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit ls - List all branches, only remote or only local\n"
    echo

  else
    printf "sgit ls - List all branches, only remote or only local\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  sgit ls [OPTIONS]\n"
  printf "  sgit ls --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--remote, -r"
    printf "    List only remote branches\n"
    echo

    # :flag.usage
    printf "  %s\n" "--local, -l"
    printf "    List only local branches\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_take_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit take - Create new branch\n"
    echo

  else
    printf "sgit take - Create new branch\n"
    echo

  fi

  printf "Alias: mkdir\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit take [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit take --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--origin, -o"
    printf "    Defines if the branch should also be created in the origin\n"
    echo

    # :flag.usage
    printf "  %s\n" "--only-origin, -O"
    printf "    Defines if the branch should be only created in the origin\n"
    echo

    # :flag.usage
    printf "  %s\n" "--main"
    printf "    The production branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--staging, -s"
    printf "    Demo branch and decisions about release features\n"
    echo

    # :flag.usage
    printf "  %s\n" "--test, -t"
    printf "    Contains all codes ready for QA testing\n"
    echo

    # :flag.usage
    printf "  %s\n" "--dev, -d"
    printf "    All new features and bug fixes; codes conflicts should be done here\n"
    echo

    # :flag.usage
    printf "  %s\n" "--feature, -f DESCRIPTION"
    printf "    Any code changes for a new module or use case; should be created based on\n    the current development branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--bugfix, -b DESCRIPTION"
    printf "    If the code changes made from the feature branch were rejected after a\n    release, sprint or demo\n"
    echo

    # :flag.usage
    printf "  %s\n" "--hotfix, -H DESCRIPTION"
    printf "    If there is a need to fix something that should be handled immediately;\n    could be merged directly to the production branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--experimental, -e DESCRIPTION"
    printf "    Any new feature or idea that is not part of a release or a sprint; a branch\n    for playing around\n"
    echo

    # :flag.usage
    printf "  %s\n" "--build, -u DESCRIPTION"
    printf "    A branch specifically for creating specific build artifacts or for doing\n    code coverage runs\n"
    echo

    # :flag.usage
    printf "  %s\n" "--release, -r DESCRIPTION"
    printf "    A branch for tagging a specific release version\n"
    echo

    # :flag.usage
    printf "  %s\n" "--merge, -m DESCRIPTION"
    printf "    Resolving merge conflicts, usually between the latest development and a\n    feature or hotfix branch; also to merge two branches of one feature\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a brief explanation about the branch purpose\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit take -f \"my really awesome feature\" -o\n"
    printf "  [Result]\n"
    printf "  - git checkout -b \"feature/my-really-awesome-feature\"\n"
    printf "  - git push origin \"feature/my-really-awesome-feature\"\n"
    echo

  fi
}

# :command.usage
sgit_cd_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit cd - Change the current working branch\n"
    echo

  else
    printf "sgit cd - Change the current working branch\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  sgit cd BRANCH\n"
  printf "  sgit cd --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "BRANCH"
    printf "    The branch to go to\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit cd main\n"
    printf "  [Result]\n"
    printf "  - git checkout \"main\"\n"
    echo

  fi
}

# :command.usage
sgit_mv_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit mv - Rename some branch\n"
    echo

  else
    printf "sgit mv - Rename some branch\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  sgit mv OLD_BRANCH NEW_BRANCH [OPTIONS]\n"
  printf "  sgit mv --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--origin, -o"
    printf "    Defines if the branch should also be renamed in the origin\n"
    echo

    # :flag.usage
    printf "  %s\n" "--only-origin, -O"
    printf "    Defines if the branch should be only renamed in the origin\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "OLD_BRANCH"
    printf "    The current branch you want to rename\n"
    echo

    # :argument.usage
    printf "  %s\n" "NEW_BRANCH"
    printf "    The new name for branch\n"
    echo

  fi
}

# :command.usage
sgit_rm_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit rm - Delete some branch\n"
    echo

  else
    printf "sgit rm - Delete some branch\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  sgit rm [BRANCH] [OPTIONS]\n"
  printf "  sgit rm --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--origin, -o"
    printf "    Defines if the branch should also be deleted in the origin\n"
    echo

    # :flag.usage
    printf "  %s\n" "--only-origin, -O"
    printf "    Defines if the branch should be only deleted in the origin\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "BRANCH"
    printf "    Branch to delete; if none are informed, delete the current one\n"
    echo

  fi
}

# :command.usage
sgit_save_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit save - Save credentials storage in git repository\n"
    echo

  else
    printf "sgit save - Save credentials storage in git repository\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  sgit save [OPTIONS]\n"
  printf "  sgit save --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--global, -g"
    printf "    Enable credentials storage globally\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_remote_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit remote - Show the current remote repository\n"
    echo

  else
    printf "sgit remote - Show the current remote repository\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  sgit remote [OPTIONS]\n"
  printf "  sgit remote --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add or replace the current origin remote repository\n"
    echo

    # :flag.usage
    printf "  %s\n" "--remove, -r"
    printf "    Remove the current origin remote repository\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_wipe_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit wipe - Wipe the working branch as per the remote branch\n"
    echo

  else
    printf "sgit wipe - Wipe the working branch as per the remote branch\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  sgit wipe [BRANCH] [OPTIONS]\n"
  printf "  sgit wipe --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--yes, -y"
    printf "    Skip confirmation\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "BRANCH"
    printf "    Branch to wipe; if none are informed, wipe the current one\n"
    echo

  fi
}

# :command.usage
sgit_rollback_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit rollback - Back the commit history, but it preserves the file contents\n"
    echo

  else
    printf "sgit rollback - Back the commit history, but it preserves the file contents\n"
    echo

  fi

  printf "Alias: rb\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit rollback [COMMIT_ID]\n"
  printf "  sgit rollback --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "COMMIT_ID"
    printf "    The commit ID; if none are informed, rollback to the last commit\n"
    echo

  fi
}

# :command.usage
sgit_edit_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit edit - Edit some commit message\n"
    echo

  else
    printf "sgit edit - Edit some commit message\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  sgit edit [COMMIT_ID]\n"
  printf "  sgit edit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "COMMIT_ID"
    printf "    The commit ID; if none are informed, edit the last commit\n"
    echo

  fi
}

# :command.usage
sgit_get_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit get - Fetch and merge changes from remote branch to working branch (pull shortcut)\n"
    echo

  else
    printf "sgit get - Fetch and merge changes from remote branch to working branch (pull shortcut)\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  sgit get [BRANCH] [OPTIONS]\n"
  printf "  sgit get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Overwrite existing local commits in case conflicts\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "BRANCH"
    printf "    Branch name to get\n"
    echo

  fi
}

# :command.usage
sgit_put_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit put - Send committed changes from working branch to the respective remote branch (push shortcut)\n"
    echo

  else
    printf "sgit put - Send committed changes from working branch to the respective remote branch (push shortcut)\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  sgit put [BRANCH] [OPTIONS]\n"
  printf "  sgit put --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Overwrite existing origin commits in case conflicts\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "BRANCH"
    printf "    Branch name to put\n"
    echo

  fi
}

# :command.usage
sgit_log_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit log - Search in the history commit by applying some filters\n"
    echo

  else
    printf "sgit log - Search in the history commit by applying some filters\n"
    echo

  fi

  printf "Alias: l\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit log [SEARCH_TERMS] [OPTIONS]\n"
  printf "  sgit log --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--author, -a AUTHOR"
    printf "    Filter by author\n"
    echo

    # :flag.usage
    printf "  %s\n" "--since, -s SINCE"
    printf "    Filter since of...\n"
    echo

    # :flag.usage
    printf "  %s\n" "--until, -u UNTIL"
    printf "    Filter until of...\n"
    echo

    # :flag.usage
    printf "  %s\n" "--exclude, -e"
    printf "    Filter excluding some term\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SEARCH_TERMS"
    printf "    Type something to search, like \"feat\" to see all feature commits\n"
    echo

  fi
}

# :command.usage
sgit_status_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit status - Show the current state of git working directory and staging area\n"
    echo

  else
    printf "sgit status - Show the current state of git working directory and staging area\n"
    echo

  fi

  printf "Alias: s\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit status\n"
  printf "  sgit status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_incoming_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit incoming - Show the incoming commits from remote branch that is not in the working branch\n"
    echo

  else
    printf "sgit incoming - Show the incoming commits from remote branch that is not in the working branch\n"
    echo

  fi

  printf "Alias: in\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit incoming\n"
  printf "  sgit incoming --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_outgoing_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit outgoing - Show the outgoing commits from working branch that is not in the remote branch\n"
    echo

  else
    printf "sgit outgoing - Show the outgoing commits from working branch that is not in the remote branch\n"
    echo

  fi

  printf "Alias: out\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit outgoing\n"
  printf "  sgit outgoing --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_committers_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit committers - Show the committers of the current branch\n"
    echo

  else
    printf "sgit committers - Show the committers of the current branch\n"
    echo

  fi

  printf "Alias: cm\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit committers\n"
  printf "  sgit committers --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_add_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit add - Add files or directories to staging area\n"
    echo

  else
    printf "sgit add - Add files or directories to staging area\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  sgit add [STRING...]\n"
  printf "  sgit add --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_sub_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit sub - Remove files or directories from staging area\n"
    echo

  else
    printf "sgit sub - Remove files or directories from staging area\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  sgit sub [OPTIONS] [STRING...]\n"
  printf "  sgit sub --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--all, -a"
    printf "    Remove all files or directories from staging area\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_amend_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit amend - Add all untracked, modified and deleted files to the last commit without edit the message\n"
    echo

  else
    printf "sgit amend - Add all untracked, modified and deleted files to the last commit without edit the message\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  sgit amend [OPTIONS]\n"
  printf "  sgit amend --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_resolve_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit resolve - Resolve conflicts in the working branch\n"
    echo

  else
    printf "sgit resolve - Resolve conflicts in the working branch\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  sgit resolve [OPTIONS]\n"
  printf "  sgit resolve --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ours, -o"
    printf "    Resolve conflicts using the working branch version\n"
    echo

    # :flag.usage
    printf "  %s\n" "--theirs, -t"
    printf "    Resolve conflicts using the remote branch version\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_tag_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit tag - Add an annotated tag with the description same as the message\n"
    echo

  else
    printf "sgit tag - Add an annotated tag with the description same as the message\n"
    echo

  fi

  printf "Alias: t\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit tag [MESSAGE]\n"
  printf "  sgit tag --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MESSAGE"
    printf "    The annotated/message\n"
    echo

  fi
}

# :command.usage
sgit_build_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit build - Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)\n"
    echo

  else
    printf "sgit build - Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)\n"
    echo

  fi

  printf "Alias: bd\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit build [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit build --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit build \"add express types\" -a package.json\n"
    printf "  [Result]\n"
    printf "  - git add package.json\n"
    printf "  - git commit -m \"build: add express types\"\n"
    echo

  fi
}

# :command.usage
sgit_chore_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit chore - Code change that external user won't see (eg: change to .gitignore file or .prettierrc file)\n"
    echo

  else
    printf "sgit chore - Code change that external user won't see (eg: change to .gitignore file or .prettierrc file)\n"
    echo

  fi

  printf "Alias: ch\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit chore [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit chore --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit chore -s \"router\" \"allow to extend other configs\" -A\n"
    printf "  [Result]\n"
    printf "  - git add --all\n"
    printf "  - git commit -m \"chore(router): update public api\"\n"
    echo

  fi
}

# :command.usage
sgit_ci_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit ci - Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs)\n"
    echo

  else
    printf "sgit ci - Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs)\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  sgit ci [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit ci --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit ci\n"
    printf "  [Result]\n"
    printf "  - git commit -m \"ci: \" --edit\n"
    printf "  - * Open default editor to complete the message *\n"
    echo

  fi
}

# :command.usage
sgit_docs_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit docs - Documentation only changes\n"
    echo

  else
    printf "sgit docs - Documentation only changes\n"
    echo

  fi

  printf "Alias: dc\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit docs [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit docs --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit docs \"update per tech review\" -Apfe\n"
    printf "  [Result]\n"
    printf "  - git add --all\n"
    printf "  - git commit -m \"docs: update per tech review\" --edit\n"
    printf "  - * Open default editor to complete the message *\n"
    printf "  - git push --force\n"
    echo

  fi
}

# :command.usage
sgit_feat_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit feat - New feature\n"
    echo

  else
    printf "sgit feat - New feature\n"
    echo

  fi

  printf "Alias: ft\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit feat [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit feat --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit feat -s \"service-worker\" \"expose more version update events\" -bea \"-p\n  src/index.ts\"\n"
    printf "  [Result]\n"
    printf "  - git add -p src/index.ts\n"
    printf "  - git commit -m \"feat(service-worker)!: expose more version update events\"\n  --edit\n"
    printf "  - * Open default editor to complete the message *\n"
    echo

  fi
}

# :command.usage
sgit_fix_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit fix - Bug fix\n"
    echo

  else
    printf "sgit fix - Bug fix\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  sgit fix [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit fix --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit fix \"clear service worker cache in safety worker\" -Aps \"service-worker\"\n"
    printf "  [Result]\n"
    printf "  - git add --all\n"
    printf "  - git commit -m \"fix(service-worker): clear service worker cache in safety\n  worker\"\n"
    printf "  - git push\n"
    echo

  fi
}

# :command.usage
sgit_localize_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit localize - Translations update\n"
    echo

  else
    printf "sgit localize - Translations update\n"
    echo

  fi

  printf "Alias: lc\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit localize [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit localize --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit localize \"add new en_US terms\" --add-all\n"
    printf "  [Result]\n"
    printf "  - git add --all\n"
    printf "  - git commit -m \"localize: add new us_en terms\"\n"
    echo

  fi
}

# :command.usage
sgit_perf_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit perf - Code change that improves performance\n"
    echo

  else
    printf "sgit perf - Code change that improves performance\n"
    echo

  fi

  printf "Alias: pf\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit perf [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit perf --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit perf \"add js-web-frameworks benchmark (#34034)\" -pa\n  \"/benchmarks/BUILD.bazel /benchmarks/perf.spec.ts\"\n"
    printf "  [Result]\n"
    printf "  - git add /benchmarks/BUILD.bazel /benchmarks/perf.spec.ts\n"
    printf "  - git commit -m \"perf: add js-web-frameworks benchmark (#34034)\"\n"
    printf "  - git push\n"
    echo

  fi
}

# :command.usage
sgit_refactor_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit refactor - Code change that neither fixes a bug nor adds a feature; refactoring production code, eg. renaming a variable\n"
    echo

  else
    printf "sgit refactor - Code change that neither fixes a bug nor adds a feature; refactoring production code, eg. renaming a variable\n"
    echo

  fi

  printf "Alias: rf\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit refactor [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit refactor --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit refactor \"allow to extend other configs\" -A\n"
    printf "  [Result]\n"
    printf "  - git add --all\n"
    printf "  - git commit -m \"refactor: remove Éµloc and related code\"\n"
    echo

  fi
}

# :command.usage
sgit_revert_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit revert - Reverts a previous commit\n"
    echo

  else
    printf "sgit revert - Reverts a previous commit\n"
    echo

  fi

  printf "Alias: rv\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit revert [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit revert --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit revert \"\`refactor(router): clean up internal hooks (#43804)\` (#43845)\"\n"
    printf "  [Result]\n"
    printf "  - git commit -m \"revert: \`refactor(router): clean up internal hooks (#43804)\`\n  (#43845)\"\n"
    echo

  fi
}

# :command.usage
sgit_style_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit style - Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)\n"
    echo

  else
    printf "sgit style - Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)\n"
    echo

  fi

  printf "Alias: st\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit style [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit style --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit style \"lint panel component\" -p\n"
    printf "  [Result]\n"
    printf "  - git commit -m \"style: lint panel component\"\n"
    printf "  - git push\n"
    echo

  fi
}

# :command.usage
sgit_test_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit test - Adding missing tests or correcting existing tests\n"
    echo

  else
    printf "sgit test - Adding missing tests or correcting existing tests\n"
    echo

  fi

  printf "Alias: ts\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit test [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit test --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit test \"remove \`document-register-element\` from elements tests\" -Ap\n"
    printf "  [Result]\n"
    printf "  - git add --all\n"
    printf "  - git commit -m \"test: remove \`document-register-element\` from elements tests\"\n"
    printf "  - git push\n"
    echo

  fi
}

# :command.usage
sgit_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit completions\n"
    echo

    printf "  Generate bash completions\n  Usage: eval \"\$(cli completions)\"\n"
    echo

  else
    printf "sgit completions - Generate bash completions\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  sgit completions\n"
  printf "  sgit completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/send_completions.sh
# [@bashly-upgrade completions send_completions]
send_completions() {
  echo $'#!/usr/bin/env bash'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $'_sgit_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local comp_line="${COMP_WORDS[*]:1}"'
  echo $''
  echo $'  case "$comp_line" in'
  echo $'    \'completions\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'rollback\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'localize\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'refactor\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'revert\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'status\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'mkdir\'*) COMPREPLY=($(compgen -W "--bugfix --build --dev --experimental --feature --help --hotfix --main --merge --only-origin --origin --release --staging --test -H -O -b -d -e -f -h -m -o -r -s -t" -- "$cur")) ;;'
  echo $'    \'style\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'amend\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'chore\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'build\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'docs\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'perf\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'feat\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'wipe\'*) COMPREPLY=($(compgen -W "$(git branch 2> /dev/null) --help --yes -h -y" -- "$cur")) ;;'
  echo $'    \'save\'*) COMPREPLY=($(compgen -W "--global --help -g -h" -- "$cur")) ;;'
  echo $'    \'test\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'edit\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'log\'*) COMPREPLY=($(compgen -W "--author --exclude --help --since --until -a -e -h -s -u" -- "$cur")) ;;'
  echo $'    \'add\'*) COMPREPLY=($(compgen -A directory -A file -W "--help -h" -- "$cur")) ;;'
  echo $'    \'tag\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'put\'*) COMPREPLY=($(compgen -W "$(git branch 2> /dev/null) --force --help -f -h" -- "$cur")) ;;'
  echo $'    \'get\'*) COMPREPLY=($(compgen -W "$(git branch 2> /dev/null) --force --help -f -h" -- "$cur")) ;;'
  echo $'    \'fix\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'sub\'*) COMPREPLY=($(compgen -A directory -A file -W "--all --help -a -h" -- "$cur")) ;;'
  echo $'    \'ci\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'rm\'*) COMPREPLY=($(compgen -W "$(git branch 2> /dev/null) --help --only-origin --origin -O -h -o" -- "$cur")) ;;'
  echo $'    \'mv\'*) COMPREPLY=($(compgen -W "$(git branch 2> /dev/null) --help --only-origin --origin -O -h -o" -- "$cur")) ;;'
  echo $'    \'ls\'*) COMPREPLY=($(compgen -W "--help --local --remote -h -l -r" -- "$cur")) ;;'
  echo $'    \'cd\'*) COMPREPLY=($(compgen -W "$(git branch 2> /dev/null) --help -h" -- "$cur")) ;;'
  echo $'    \'\'*) COMPREPLY=($(compgen -W "--help --version -h -v add amend build cd chore ci completions docs edit feat fix get localize log ls mkdir mv perf put refactor revert rm rollback save status style sub tag test wipe" -- "$cur")) ;;'
  echo $'  esac'
  echo $'}'
  echo $''
  echo $'complete -F _sgit_completions sgit'
}

# :command.command_functions
# :command.function
sgit_ls_command() {
  # src/ls_command.sh
  if [ ! -z ${args[--local]} ]; then
    git branch -l | grep -v âremotesâ
  elif [ ! -z ${args[--remote]} ]; then
    git branch -r | grep -v âremotesâ
  else
    git branch -a | grep -v âremotesâ
  fi

}

# :command.function
sgit_take_command() {
  # src/take_command.sh
  if [ ! -z "${args['description']}" ]; then
    branch=${args['description']}
  elif [ ! -z "${args['--main']}" ]; then
    branch=main
  elif [ ! -z "${args['--staging']}" ]; then
    branch=staged
  elif [ ! -z "${args['--test']}" ]; then
    branch=test
  elif [ ! -z "${args['--dev']}" ]; then
    branch=develop
  elif [ ! -z "${args['--feature']}" ]; then
    branch=feature/${args['--feature']}
  elif [ ! -z "${args['--bugfix']}" ]; then
    branch=bugfix/${args['--bugfix']}
  elif [ ! -z "${args['--hotfix']}" ]; then
    branch=hotfix/${args['--hotfix']}
  elif [ ! -z "${args['--experimental']}" ]; then
    branch=experimental/${args['--experimental']}
  elif [ ! -z "${args['--build']}" ]; then
    branch=build/${args['--build']}
  elif [ ! -z "${args['--release']}" ]; then
    branch=release/${args['--release']}
  elif [ ! -z "${args['--merge']}" ]; then
    branch=merge/${args['--merge']}
  fi

  branch=${branch// /-}

  if [ ! -z ${args['--only-origin']} ]; then
    git push -u origin $branch
  elif [ ! -z ${args['--origin']} ]; then
    git checkout -b $branch
    git push -u origin $branch
  else
    git checkout -b $branch
  fi
}

# :command.function
sgit_cd_command() {
  # src/cd_command.sh
  git checkout ${args[branch]}

}

# :command.function
sgit_mv_command() {
  # src/mv_command.sh
  if [ ! -z ${args[--only-origin]} ]; then
    git push origin origin/${args[old_branch]}:refs/heads/${args[new_branch]} :${args[old_branch]}
  elif [ ! -z ${args[--origin]} ]; then
    git branch -m ${args[old_branch]} ${args[new_branch]}
    git push origin origin/${args[old_branch]}:refs/heads/${args[new_branch]} :${args[old_branch]}
  else
    git branch -m ${args[old_branch]} ${args[new_branch]}
  fi

}

# :command.function
sgit_rm_command() {
  # src/rm_command.sh
  if [ ! -z ${args[--only-origin]} ]; then
    git push origin --delete ${args[branch]}
  else
    if [ ${args[branch]} == "$(git branch --show-current)" ]; then
      branches=$(git branch -l)
      IFS=$'\n'
      branches=($branches)
      current_branch=$(git rev-parse --abbrev-ref HEAD)
      jump_branch=$([[ "*$current_branch" == "${branches[0]// /}" ]] && echo "${branches[1]// /}" || echo "${branches[0]// /}")
      git checkout $jump_branch
    fi
    git branch -D ${args[branch]}
    if [ ! -z ${args[--origin]} ]; then
      git push origin --delete ${args[branch]}
    fi
  fi

}

# :command.function
sgit_save_command() {
  # src/save_command.sh
  if [ ! -z ${args[--global]} ]; then
    git config --global credential.helper store
  else
    git config credential.helper store
  fi

}

# :command.function
sgit_remote_command() {
  # src/remote_command.sh
  if [ ! -z "${args[--add]}" ]; then # Add or replace the current origin remote repository"
    git remote rm origin
    git remote add origin ${args[--add]}
  fi

  if [ ! -z "${args[--add-all]}" ]; then # Add or replace the current origin remote repository"
    git remote rm origin
    git remote add origin ${args[--add-all]}
  fi

  git remote -v | awk '{print $2}' | sort -u

}

# :command.function
sgit_wipe_command() {
  # src/wipe_command.sh
  branch=$([[ ! -z "${args[branch]}" ]] && echo ${args[branch]} || echo $(git rev-parse --abbrev-ref HEAD))

  if [ ! -z ${args[--yes]} ]; then
    git reset --hard origin/$branch
  else
    echo "Are you sure you want to wipe (hard reset) \"$branch\" branch? (y/N)"
    read REPLY
    if [[ "$REPLY" =~ ^[Yy]$ ]]; then
      git reset --hard origin/$branch
    fi
  fi

}

# :command.function
sgit_rollback_command() {
  # src/rollback_command.sh
  if [ ! -z ${args[commit_id]} ]; then
    git reset --soft ${args[commit_id]}
  else
    git reset --soft HEAD~1
  fi
  git reset
}

# :command.function
sgit_edit_command() {
  # src/edit_command.sh
  if [ -z ${args[commit_id]} ]; then
    git commit --amend
  else
    HEAD_COMMIT=$(git rev-list HEAD | nl | grep ${args[commit_id]})
    read HEAD_ID _ <<<"$HEAD_COMMIT"

    echo "==========================="
    echo
    echo "ATTENTION! Alter \"pick\" to \"reword\" in the commit you want to edit."
    echo "After that, save and close the file, so you will be able to edit the commit message."
    echo ""
    echo "To publish you must run \"git put --force\"."
    echo "This is NOT RECOMMENDED if commits have already been made to a remote repository and other collaborators are active."
    echo
    echo "==========================="

    git rebase -i HEAD~$HEAD_ID

  fi
}

# :command.function
sgit_get_command() {
  # src/get_command.sh
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")
  branch=$([[ ! -z "${args[branch]}" ]] && echo ${args[branch]} || echo $(git rev-parse --abbrev-ref HEAD))

  git pull $force origin $branch

}

# :command.function
sgit_put_command() {
  # src/put_command.sh
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")
  branch=$([[ ! -z "${args[branch]}" ]] && echo ${args[branch]} || echo $(git rev-parse --abbrev-ref HEAD))

  git push $force origin $branch

}

# :command.function
sgit_log_command() {
  # src/log_command.sh
  query+=$([[ ! -z "${args[search_terms]}" ]] && echo "--grep ${args[search_terms]} " || echo "")
  query+=$([[ ! -z "${args[--author]}" ]] && echo "--author ${args[--author]} " || echo "")
  query+=$([[ ! -z "${args[--since]}" ]] && echo "--since ${args[--since]} " || echo "")
  query+=$([[ ! -z "${args[--until]}" ]] && echo "--until ${args[--until]} " || echo "")
  query+=$([[ ! -z "${args[--exclude]}" ]] && echo "--invert-grep " || echo "")

  git log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %C(green)(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit $query
}

# :command.function
sgit_status_command() {
  # src/status_command.sh
  git status -s

}

# :command.function
sgit_incoming_command() {
  # src/incoming_command.sh
  # Show the incoming commits from remote branch that is not in the working branch
  git fetch origin --quiet
  git log --oneline --no-merges --left-only --cherry-pick --decorate --pretty=format:"%C(yellow)%h %Cgreen%cr %Cblue%an%Creset %s" $(git rev-parse --abbrev-ref HEAD)..origin/$(git rev-parse --abbrev-ref HEAD)

}

# :command.function
sgit_outgoing_command() {
  # src/outgoing_command.sh
  # Show the outgoing commits from working branch that is not in the remote branch
  git fetch origin --quiet
  git log --oneline --no-merges --right-only --cherry-pick --decorate --pretty=format:"%C(yellow)%h %Cgreen%cr %Cblue%an%Creset %s" origin/$(git rev-parse --abbrev-ref HEAD)..$(git rev-parse --abbrev-ref HEAD)

}

# :command.function
sgit_committers_command() {
  # src/committers_command.sh
  git log | grep Author | sort | uniq -c | sort -n -r

}

# :command.function
sgit_add_command() {
  # src/add_command.sh
  git add ${other_args[*]}
}

# :command.function
sgit_sub_command() {
  # src/sub_command.sh
  if [ ! -z "${args[--all]}" ]; then
    git reset
  else
    git restore --staged ${other_args[*]}
  fi

}

# :command.function
sgit_amend_command() {
  # src/amend_command.sh
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit --amend --no-edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_resolve_command() {
  # src/resolve_command.sh
  if [ ! -z "${args[--ours]}" ]; then # Resolve conflicts using the working branch version"
    git checkout --ours .
  fi

  if [ ! -z "${args[--theirs]}" ]; then # Resolve conflicts using the remote branch version"
    git checkout --theirs .
  fi

}

# :command.function
sgit_tag_command() {
  # src/tag_command.sh
  git config --global push.followTags true
  git tag -a ${args[message]} -m ${args[message]}
}

# :command.function
sgit_build_command() {
  # src/build_command.sh
  type=build
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_chore_command() {
  # src/chore_command.sh
  type=chore
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_ci_command() {
  # src/ci_command.sh
  type=ci
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_docs_command() {
  # src/docs_command.sh
  type=docs
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_feat_command() {
  # src/feat_command.sh
  type=feat
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_fix_command() {
  # src/fix_command.sh
  type=fix
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_localize_command() {
  # src/localize_command.sh
  type=localize
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_perf_command() {
  # src/perf_command.sh
  type=perf
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_refactor_command() {
  # src/refactor_command.sh
  type=refactor
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_revert_command() {
  # src/revert_command.sh
  type=revert
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_style_command() {
  # src/style_command.sh
  type=style
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_test_command() {
  # src/test_command.sh
  type=test
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_completions_command() {
  # src/completions_command.sh
  # Call the `send_completions` function which was added by running:
  #
  #   $ bashly add comp function
  #
  # Users can now enable bash completion for this script by running:
  #
  #   $ eval "$(sgit completions)"
  #
  send_completions
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        sgit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    ls)
      action="ls"
      shift
      sgit_ls_parse_requirements "$@"
      shift $#
      ;;

    take | mkdir)
      action="take"
      shift
      sgit_take_parse_requirements "$@"
      shift $#
      ;;

    cd)
      action="cd"
      shift
      sgit_cd_parse_requirements "$@"
      shift $#
      ;;

    mv)
      action="mv"
      shift
      sgit_mv_parse_requirements "$@"
      shift $#
      ;;

    rm)
      action="rm"
      shift
      sgit_rm_parse_requirements "$@"
      shift $#
      ;;

    save)
      action="save"
      shift
      sgit_save_parse_requirements "$@"
      shift $#
      ;;

    remote)
      action="remote"
      shift
      sgit_remote_parse_requirements "$@"
      shift $#
      ;;

    wipe)
      action="wipe"
      shift
      sgit_wipe_parse_requirements "$@"
      shift $#
      ;;

    rollback | rb)
      action="rollback"
      shift
      sgit_rollback_parse_requirements "$@"
      shift $#
      ;;

    edit)
      action="edit"
      shift
      sgit_edit_parse_requirements "$@"
      shift $#
      ;;

    get)
      action="get"
      shift
      sgit_get_parse_requirements "$@"
      shift $#
      ;;

    put)
      action="put"
      shift
      sgit_put_parse_requirements "$@"
      shift $#
      ;;

    log | l)
      action="log"
      shift
      sgit_log_parse_requirements "$@"
      shift $#
      ;;

    status | s)
      action="status"
      shift
      sgit_status_parse_requirements "$@"
      shift $#
      ;;

    incoming | in)
      action="incoming"
      shift
      sgit_incoming_parse_requirements "$@"
      shift $#
      ;;

    outgoing | out)
      action="outgoing"
      shift
      sgit_outgoing_parse_requirements "$@"
      shift $#
      ;;

    committers | cm)
      action="committers"
      shift
      sgit_committers_parse_requirements "$@"
      shift $#
      ;;

    add)
      action="add"
      shift
      sgit_add_parse_requirements "$@"
      shift $#
      ;;

    sub)
      action="sub"
      shift
      sgit_sub_parse_requirements "$@"
      shift $#
      ;;

    amend)
      action="amend"
      shift
      sgit_amend_parse_requirements "$@"
      shift $#
      ;;

    resolve)
      action="resolve"
      shift
      sgit_resolve_parse_requirements "$@"
      shift $#
      ;;

    tag | t)
      action="tag"
      shift
      sgit_tag_parse_requirements "$@"
      shift $#
      ;;

    build | bd)
      action="build"
      shift
      sgit_build_parse_requirements "$@"
      shift $#
      ;;

    chore | ch)
      action="chore"
      shift
      sgit_chore_parse_requirements "$@"
      shift $#
      ;;

    ci)
      action="ci"
      shift
      sgit_ci_parse_requirements "$@"
      shift $#
      ;;

    docs | dc)
      action="docs"
      shift
      sgit_docs_parse_requirements "$@"
      shift $#
      ;;

    feat | ft)
      action="feat"
      shift
      sgit_feat_parse_requirements "$@"
      shift $#
      ;;

    fix)
      action="fix"
      shift
      sgit_fix_parse_requirements "$@"
      shift $#
      ;;

    localize | lc)
      action="localize"
      shift
      sgit_localize_parse_requirements "$@"
      shift $#
      ;;

    perf | pf)
      action="perf"
      shift
      sgit_perf_parse_requirements "$@"
      shift $#
      ;;

    refactor | rf)
      action="refactor"
      shift
      sgit_refactor_parse_requirements "$@"
      shift $#
      ;;

    revert | rv)
      action="revert"
      shift
      sgit_revert_parse_requirements "$@"
      shift $#
      ;;

    style | st)
      action="style"
      shift
      sgit_style_parse_requirements "$@"
      shift $#
      ;;

    test | ts)
      action="test"
      shift
      sgit_test_parse_requirements "$@"
      shift $#
      ;;

    completions)
      action="completions"
      shift
      sgit_completions_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      sgit_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_ls_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_ls_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="ls"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --remote | -r)

        # :flag.case_no_arg
        args['--remote']=1
        shift
        ;;

      # :flag.case
      --local | -l)

        # :flag.case_no_arg
        args['--local']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_take_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_take_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="take"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --origin | -o)

        # :flag.case_no_arg
        args['--origin']=1
        shift
        ;;

      # :flag.case
      --only-origin | -O)

        # :flag.case_no_arg
        args['--only-origin']=1
        shift
        ;;

      # :flag.case
      --main)

        # :flag.case_no_arg
        args['--main']=1
        shift
        ;;

      # :flag.case
      --staging | -s)

        # :flag.case_no_arg
        args['--staging']=1
        shift
        ;;

      # :flag.case
      --test | -t)

        # :flag.case_no_arg
        args['--test']=1
        shift
        ;;

      # :flag.case
      --dev | -d)

        # :flag.case_no_arg
        args['--dev']=1
        shift
        ;;

      # :flag.case
      --feature | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--feature']="$2"
          shift
          shift
        else
          printf "%s\n" "--feature requires an argument: --feature, -f DESCRIPTION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --bugfix | -b)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--bugfix']="$2"
          shift
          shift
        else
          printf "%s\n" "--bugfix requires an argument: --bugfix, -b DESCRIPTION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --hotfix | -H)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--hotfix']="$2"
          shift
          shift
        else
          printf "%s\n" "--hotfix requires an argument: --hotfix, -H DESCRIPTION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --experimental | -e)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--experimental']="$2"
          shift
          shift
        else
          printf "%s\n" "--experimental requires an argument: --experimental, -e DESCRIPTION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --build | -u)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--build']="$2"
          shift
          shift
        else
          printf "%s\n" "--build requires an argument: --build, -u DESCRIPTION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --release | -r)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--release']="$2"
          shift
          shift
        else
          printf "%s\n" "--release requires an argument: --release, -r DESCRIPTION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --merge | -m)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--merge']="$2"
          shift
          shift
        else
          printf "%s\n" "--merge requires an argument: --merge, -m DESCRIPTION" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['description']+x} ]]; then

          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_cd_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_cd_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="cd"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['branch']+x} ]]; then

          args['branch']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['branch']+x} ]]; then
    printf "missing required argument: BRANCH\nusage: sgit cd BRANCH\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
sgit_mv_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_mv_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="mv"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --origin | -o)

        # :flag.case_no_arg
        args['--origin']=1
        shift
        ;;

      # :flag.case
      --only-origin | -O)

        # :flag.case_no_arg
        args['--only-origin']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['old_branch']+x} ]]; then

          args['old_branch']=$1
          shift
        elif [[ -z ${args['new_branch']+x} ]]; then

          args['new_branch']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['old_branch']+x} ]]; then
    printf "missing required argument: OLD_BRANCH\nusage: sgit mv OLD_BRANCH NEW_BRANCH [OPTIONS]\n" >&2
    exit 1
  fi
  if [[ -z ${args['new_branch']+x} ]]; then
    printf "missing required argument: NEW_BRANCH\nusage: sgit mv OLD_BRANCH NEW_BRANCH [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
sgit_rm_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_rm_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="rm"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --origin | -o)

        # :flag.case_no_arg
        args['--origin']=1
        shift
        ;;

      # :flag.case
      --only-origin | -O)

        # :flag.case_no_arg
        args['--only-origin']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['branch']+x} ]]; then

          args['branch']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_save_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_save_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="save"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --global | -g)

        # :flag.case_no_arg
        args['--global']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_remote_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_remote_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="remote"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --remove | -r)

        # :flag.case_no_arg
        args['--remove']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_wipe_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_wipe_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="wipe"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --yes | -y)

        # :flag.case_no_arg
        args['--yes']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['branch']+x} ]]; then

          args['branch']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_rollback_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_rollback_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="rollback"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['commit_id']+x} ]]; then

          args['commit_id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_edit_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_edit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="edit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['commit_id']+x} ]]; then

          args['commit_id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_get_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['branch']+x} ]]; then

          args['branch']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_put_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_put_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="put"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['branch']+x} ]]; then

          args['branch']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_log_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_log_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="log"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --author | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--author']="$2"
          shift
          shift
        else
          printf "%s\n" "--author requires an argument: --author, -a AUTHOR" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --since | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--since']="$2"
          shift
          shift
        else
          printf "%s\n" "--since requires an argument: --since, -s SINCE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --until | -u)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--until']="$2"
          shift
          shift
        else
          printf "%s\n" "--until requires an argument: --until, -u UNTIL" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --exclude | -e)

        # :flag.case_no_arg
        args['--exclude']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['search_terms']+x} ]]; then

          args['search_terms']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_incoming_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_incoming_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="incoming"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_outgoing_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_outgoing_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="outgoing"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_committers_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_committers_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="committers"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_add_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="add"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_sub_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_sub_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="sub"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --all | -a)

        # :flag.case_no_arg
        args['--all']=1
        shift
        ;;

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_amend_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_amend_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="amend"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_resolve_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_resolve_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="resolve"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ours | -o)

        # :flag.case_no_arg
        args['--ours']=1
        shift
        ;;

      # :flag.case
      --theirs | -t)

        # :flag.case_no_arg
        args['--theirs']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_tag_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_tag_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tag"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['message']+x} ]]; then

          args['message']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_build_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_build_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="build"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['description']+x} ]]; then

          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_chore_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_chore_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="chore"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['description']+x} ]]; then

          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_ci_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_ci_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="ci"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['description']+x} ]]; then

          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_docs_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_docs_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="docs"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['description']+x} ]]; then

          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_feat_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_feat_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="feat"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['description']+x} ]]; then

          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_fix_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_fix_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fix"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['description']+x} ]]; then

          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_localize_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_localize_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="localize"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['description']+x} ]]; then

          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_perf_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_perf_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="perf"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['description']+x} ]]; then

          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_refactor_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_refactor_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="refactor"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['description']+x} ]]; then

          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_revert_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_revert_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="revert"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['description']+x} ]]; then

          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_style_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_style_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="style"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['description']+x} ]]; then

          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_test_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_test_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['description']+x} ]]; then

          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_completions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        sgit_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.2.0"
  long_usage=''
  set -e

  # src/initialize.sh
  # Code here runs inside the initialize() function
  # Use it for anything that you need to run before any other function, like
  # setting environment vairables:
  # CONFIG_FILE=settings.ini
  #
  # Feel free to empty (but not delete) this file.

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "ls") sgit_ls_command ;;
    "take") sgit_take_command ;;
    "cd") sgit_cd_command ;;
    "mv") sgit_mv_command ;;
    "rm") sgit_rm_command ;;
    "save") sgit_save_command ;;
    "remote") sgit_remote_command ;;
    "wipe") sgit_wipe_command ;;
    "rollback") sgit_rollback_command ;;
    "edit") sgit_edit_command ;;
    "get") sgit_get_command ;;
    "put") sgit_put_command ;;
    "log") sgit_log_command ;;
    "status") sgit_status_command ;;
    "incoming") sgit_incoming_command ;;
    "outgoing") sgit_outgoing_command ;;
    "committers") sgit_committers_command ;;
    "add") sgit_add_command ;;
    "sub") sgit_sub_command ;;
    "amend") sgit_amend_command ;;
    "resolve") sgit_resolve_command ;;
    "tag") sgit_tag_command ;;
    "build") sgit_build_command ;;
    "chore") sgit_chore_command ;;
    "ci") sgit_ci_command ;;
    "docs") sgit_docs_command ;;
    "feat") sgit_feat_command ;;
    "fix") sgit_fix_command ;;
    "localize") sgit_localize_command ;;
    "perf") sgit_perf_command ;;
    "refactor") sgit_refactor_command ;;
    "revert") sgit_revert_command ;;
    "style") sgit_style_command ;;
    "test") sgit_test_command ;;
    "completions") sgit_completions_command ;;
  esac
}

initialize
run "$@"
