#!/usr/bin/env bash
# This script was generated by bashly 1.2.13 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
sgit_usage() {
  printf "sgit - Syntactic sugar for Git, respecting semantics and modern conventions\n\n"

  printf "%s\n" "Usage:"
  printf "  sgit COMMAND\n"
  printf "  sgit [COMMAND] --help | -h\n"
  printf "  sgit --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Branches Commands:"
  printf "  %s   List all branches, only remote or only local\n" "ls         "
  printf "  %s   Create new branch\n" "take       "
  printf "  %s   Change the current working branch\n" "cd         "
  printf "  %s   Rename some branch\n" "mv         "
  printf "  %s   Delete some branch\n" "rm         "
  echo
  printf "%s\n" "State Commands:"
  printf "  %s   Save credentials storage in git repository\n" "save       "
  printf "  %s   Show the current remote repository\n" "remote     "
  printf "  %s   Wipe the working branch as per the remote branch\n" "wipe       "
  printf "  %s   Back the commit history, but it preserves the file contents\n" "rollback   "
  printf "  %s   Edit some commit message\n" "edit       "
  printf "  %s   Fetch and merge changes from remote branch to working branch (pull shortcut)\n" "get        "
  printf "  %s   Send committed changes from working branch to the respective remote branch (push shortcut)\n" "put        "
  echo
  printf "%s\n" "Consult Commands:"
  printf "  %s   Search in the history commit by applying some filters\n" "log        "
  printf "  %s   Show the current state of git working directory and staging area\n" "status     "
  printf "  %s   Show the incoming commits from remote branch that is not in the working branch\n" "incoming   "
  printf "  %s   Show the outgoing commits from working branch that is not in the remote branch\n" "outgoing   "
  printf "  %s   Show the committers of the current branch\n" "committers "
  echo
  printf "%s\n" "Staging Commands:"
  printf "  %s   Add files or directories to staging area\n" "add        "
  printf "  %s   Remove files or directories from staging area\n" "sub        "
  printf "  %s   Add all untracked, modified and deleted files to the last commit without edit the message\n" "amend      "
  printf "  %s   Resolve conflicts in the working branch\n" "resolve    "
  printf "  %s   Add an annotated tag with the description same as the message\n" "tag        "
  echo
  printf "%s\n" "Commit Commands:"
  printf "  %s   Use AI to generate a commit message according the description in any language\n" "commit     "
  printf "  %s   Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)\n" "build      "
  printf "  %s   Code change that external user won't see (eg: change to .gitignore file or .prettierrc file)\n" "chore      "
  printf "  %s   Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs)\n" "ci         "
  printf "  %s   Documentation only changes\n" "docs       "
  printf "  %s   New feature\n" "feat       "
  printf "  %s   Bug fix\n" "fix        "
  printf "  %s   Translations update\n" "localize   "
  printf "  %s   Code change that improves performance\n" "perf       "
  printf "  %s   Code change that neither fixes a bug nor adds a feature; refactoring production code, eg. renaming a variable\n" "refactor   "
  printf "  %s   Reverts a previous commit\n" "revert     "
  printf "  %s   Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)\n" "style      "
  printf "  %s   Adding missing tests or correcting existing tests\n" "test       "
  echo
  printf "%s\n" "Completions Commands:"
  printf "  %s   Generate bash completions\n" "completions"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
sgit_ls_usage() {
  printf "sgit ls - List all branches, only remote or only local\n\n"

  printf "%s\n" "Usage:"
  printf "  sgit ls [OPTIONS]\n"
  printf "  sgit ls --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--remote, -r"
    printf "    List only remote branches\n"
    echo

    # :flag.usage
    printf "  %s\n" "--local, -l"
    printf "    List only local branches\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_take_usage() {
  printf "sgit take - Create new branch\n\n"
  printf "Alias: mkdir\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit take [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit take --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--origin, -o"
    printf "    Defines if the branch should also be created in the origin\n"
    echo

    # :flag.usage
    printf "  %s\n" "--only-origin, -O"
    printf "    Defines if the branch should be only created in the origin\n"
    echo

    # :flag.usage
    printf "  %s\n" "--main"
    printf "    The production branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--staging, -s"
    printf "    Demo branch and decisions about release features\n"
    echo

    # :flag.usage
    printf "  %s\n" "--test, -t"
    printf "    Contains all codes ready for QA testing\n"
    echo

    # :flag.usage
    printf "  %s\n" "--dev, -d"
    printf "    All new features and bug fixes; codes conflicts should be done here\n"
    echo

    # :flag.usage
    printf "  %s\n" "--feature, -f DESCRIPTION"
    printf "    Any code changes for a new module or use case; should be created based on\n    the current development branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--bugfix, -b DESCRIPTION"
    printf "    If the code changes made from the feature branch were rejected after a\n    release, sprint or demo\n"
    echo

    # :flag.usage
    printf "  %s\n" "--hotfix, -H DESCRIPTION"
    printf "    If there is a need to fix something that should be handled immediately;\n    could be merged directly to the production branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--experimental, -e DESCRIPTION"
    printf "    Any new feature or idea that is not part of a release or a sprint; a branch\n    for playing around\n"
    echo

    # :flag.usage
    printf "  %s\n" "--build, -u DESCRIPTION"
    printf "    A branch specifically for creating specific build artifacts or for doing\n    code coverage runs\n"
    echo

    # :flag.usage
    printf "  %s\n" "--release, -r DESCRIPTION"
    printf "    A branch for tagging a specific release version\n"
    echo

    # :flag.usage
    printf "  %s\n" "--merge, -m DESCRIPTION"
    printf "    Resolving merge conflicts, usually between the latest development and a\n    feature or hotfix branch; also to merge two branches of one feature\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a brief explanation about the branch purpose\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit take -f \"my really awesome feature\" -o\n"
    printf "  [Result]\n"
    printf "  - git checkout -b \"feature/my-really-awesome-feature\"\n"
    printf "  - git push origin \"feature/my-really-awesome-feature\"\n"
    echo

  fi
}

# :command.usage
sgit_cd_usage() {
  printf "sgit cd - Change the current working branch\n\n"

  printf "%s\n" "Usage:"
  printf "  sgit cd BRANCH\n"
  printf "  sgit cd --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "BRANCH"
    printf "    The branch to go to\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit cd main\n"
    printf "  [Result]\n"
    printf "  - git checkout \"main\"\n"
    echo

  fi
}

# :command.usage
sgit_mv_usage() {
  printf "sgit mv - Rename some branch\n\n"

  printf "%s\n" "Usage:"
  printf "  sgit mv OLD_BRANCH NEW_BRANCH [OPTIONS]\n"
  printf "  sgit mv --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--origin, -o"
    printf "    Defines if the branch should also be renamed in the origin\n"
    echo

    # :flag.usage
    printf "  %s\n" "--only-origin, -O"
    printf "    Defines if the branch should be only renamed in the origin\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "OLD_BRANCH"
    printf "    The current branch you want to rename\n"
    echo

    # :argument.usage
    printf "  %s\n" "NEW_BRANCH"
    printf "    The new name for branch\n"
    echo

  fi
}

# :command.usage
sgit_rm_usage() {
  printf "sgit rm - Delete some branch\n\n"

  printf "%s\n" "Usage:"
  printf "  sgit rm [BRANCH] [OPTIONS]\n"
  printf "  sgit rm --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--origin, -o"
    printf "    Defines if the branch should also be deleted in the origin\n"
    echo

    # :flag.usage
    printf "  %s\n" "--only-origin, -O"
    printf "    Defines if the branch should be only deleted in the origin\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "BRANCH"
    printf "    Branch to delete; if none are informed, delete the current one\n"
    echo

  fi
}

# :command.usage
sgit_save_usage() {
  printf "sgit save - Save credentials storage in git repository\n\n"

  printf "%s\n" "Usage:"
  printf "  sgit save [OPTIONS]\n"
  printf "  sgit save --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--global, -g"
    printf "    Enable credentials storage globally\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_remote_usage() {
  printf "sgit remote - Show the current remote repository\n\n"

  printf "%s\n" "Usage:"
  printf "  sgit remote [OPTIONS]\n"
  printf "  sgit remote --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add or replace the current origin remote repository\n"
    echo

    # :flag.usage
    printf "  %s\n" "--remove, -r"
    printf "    Remove the current origin remote repository\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_wipe_usage() {
  printf "sgit wipe - Wipe the working branch as per the remote branch\n\n"

  printf "%s\n" "Usage:"
  printf "  sgit wipe [BRANCH] [OPTIONS]\n"
  printf "  sgit wipe --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--yes, -y"
    printf "    Skip confirmation\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "BRANCH"
    printf "    Branch to wipe; if none are informed, wipe the current one\n"
    echo

  fi
}

# :command.usage
sgit_rollback_usage() {
  printf "sgit rollback - Back the commit history, but it preserves the file contents\n\n"
  printf "Alias: rb\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit rollback [COMMIT_ID]\n"
  printf "  sgit rollback --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "COMMIT_ID"
    printf "    The commit ID; if none are informed, rollback to the last commit\n"
    echo

  fi
}

# :command.usage
sgit_edit_usage() {
  printf "sgit edit - Edit some commit message\n\n"

  printf "%s\n" "Usage:"
  printf "  sgit edit [COMMIT_ID]\n"
  printf "  sgit edit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "COMMIT_ID"
    printf "    The commit ID; if none are informed, edit the last commit\n"
    echo

  fi
}

# :command.usage
sgit_get_usage() {
  printf "sgit get - Fetch and merge changes from remote branch to working branch (pull shortcut)\n\n"

  printf "%s\n" "Usage:"
  printf "  sgit get [BRANCH] [OPTIONS]\n"
  printf "  sgit get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Overwrite existing local commits in case conflicts\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "BRANCH"
    printf "    Branch name to get\n"
    echo

  fi
}

# :command.usage
sgit_put_usage() {
  printf "sgit put - Send committed changes from working branch to the respective remote branch (push shortcut)\n\n"

  printf "%s\n" "Usage:"
  printf "  sgit put [BRANCH] [OPTIONS]\n"
  printf "  sgit put --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Overwrite existing origin commits in case conflicts\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "BRANCH"
    printf "    Branch name to put\n"
    echo

  fi
}

# :command.usage
sgit_log_usage() {
  printf "sgit log - Search in the history commit by applying some filters\n\n"
  printf "Alias: l\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit log [SEARCH_TERMS] [OPTIONS]\n"
  printf "  sgit log --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--author, -a AUTHOR"
    printf "    Filter by author\n"
    echo

    # :flag.usage
    printf "  %s\n" "--since, -s SINCE"
    printf "    Filter since of...\n"
    echo

    # :flag.usage
    printf "  %s\n" "--until, -u UNTIL"
    printf "    Filter until of...\n"
    echo

    # :flag.usage
    printf "  %s\n" "--exclude, -e"
    printf "    Filter excluding some term\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SEARCH_TERMS"
    printf "    Type something to search, like \"feat\" to see all feature commits\n"
    echo

  fi
}

# :command.usage
sgit_status_usage() {
  printf "sgit status - Show the current state of git working directory and staging area\n\n"
  printf "Alias: s\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit status\n"
  printf "  sgit status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_incoming_usage() {
  printf "sgit incoming - Show the incoming commits from remote branch that is not in the working branch\n\n"
  printf "Alias: in\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit incoming\n"
  printf "  sgit incoming --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_outgoing_usage() {
  printf "sgit outgoing - Show the outgoing commits from working branch that is not in the remote branch\n\n"
  printf "Alias: out\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit outgoing\n"
  printf "  sgit outgoing --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_committers_usage() {
  printf "sgit committers - Show the committers of the current branch\n\n"
  printf "Alias: cm\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit committers\n"
  printf "  sgit committers --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_add_usage() {
  printf "sgit add - Add files or directories to staging area\n\n"

  printf "%s\n" "Usage:"
  printf "  sgit add [--] [STRING...]\n"
  printf "  sgit add --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_sub_usage() {
  printf "sgit sub - Remove files or directories from staging area\n\n"

  printf "%s\n" "Usage:"
  printf "  sgit sub [OPTIONS] [--] [STRING...]\n"
  printf "  sgit sub --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--all, -a"
    printf "    Remove all files or directories from staging area\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_amend_usage() {
  printf "sgit amend - Add all untracked, modified and deleted files to the last commit without edit the message\n\n"

  printf "%s\n" "Usage:"
  printf "  sgit amend [OPTIONS]\n"
  printf "  sgit amend --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--date, -d DATE"
    printf "    Set commit date in YYYY-MM-DD format (must be used with --time)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--time, -t TIME"
    printf "    Set commit time in HH:MM:SS format (must be used with --date)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_resolve_usage() {
  printf "sgit resolve - Resolve conflicts in the working branch\n\n"

  printf "%s\n" "Usage:"
  printf "  sgit resolve [OPTIONS]\n"
  printf "  sgit resolve --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ours, -o"
    printf "    Resolve conflicts using the working branch version\n"
    echo

    # :flag.usage
    printf "  %s\n" "--theirs, -t"
    printf "    Resolve conflicts using the remote branch version\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
sgit_tag_usage() {
  printf "sgit tag - Add an annotated tag with the description same as the message\n\n"
  printf "Alias: t\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit tag [MESSAGE]\n"
  printf "  sgit tag --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MESSAGE"
    printf "    The annotated/message\n"
    echo

  fi
}

# :command.usage
sgit_commit_usage() {
  printf "sgit commit - Use AI to generate a commit message according the description in any language\n\n"
  printf "Alias: c\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit commit [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit commit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--date, -d DATE"
    printf "    Set commit date in YYYY-MM-DD format (must be used with --time)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--time, -t TIME"
    printf "    Set commit time in HH:MM:SS format (must be used with --date)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description can be short or long depending on the changes made to the\n    project code\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit commit \"I refactored all the buttons to be aggregated into just a\n  single component that has a variant and size property\" -Ae\n"
    printf "  [Result]\n"
    printf "  - * Open selector to choose: *\n"
    printf "     ( ) refactor: organize buttons into a single component with variant and\n  size properties\n"
    printf "     ( ) refactor: restructure buttons into a single component with variant and\n  size options\n"
    printf "     (x) refactor: consolidate all buttons into a single component with variant\n  and size properties\n"
    printf "  - git add --all\n"
    printf "  - git commit -m \"refactor: consolidate all buttons into a single component\n  with variant and size properties\" --edit\n"
    printf "  - * Open default editor to complete the message *\n"
    echo

  fi
}

# :command.usage
sgit_build_usage() {
  printf "sgit build - Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)\n\n"
  printf "Alias: bd\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit build [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit build --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--date, -d DATE"
    printf "    Set commit date in YYYY-MM-DD format (must be used with --time)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--time, -t TIME"
    printf "    Set commit time in HH:MM:SS format (must be used with --date)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit build \"add express types\" -a package.json\n"
    printf "  [Result]\n"
    printf "  - git add package.json\n"
    printf "  - git commit -m \"build: add express types\"\n"
    echo

  fi
}

# :command.usage
sgit_chore_usage() {
  printf "sgit chore - Code change that external user won't see (eg: change to .gitignore file or .prettierrc file)\n\n"
  printf "Alias: ch\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit chore [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit chore --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--date, -d DATE"
    printf "    Set commit date in YYYY-MM-DD format (must be used with --time)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--time, -t TIME"
    printf "    Set commit time in HH:MM:SS format (must be used with --date)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit chore -s \"router\" \"allow to extend other configs\" -A\n"
    printf "  [Result]\n"
    printf "  - git add --all\n"
    printf "  - git commit -m \"chore(router): update public api\"\n"
    echo

  fi
}

# :command.usage
sgit_ci_usage() {
  printf "sgit ci - Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs)\n\n"

  printf "%s\n" "Usage:"
  printf "  sgit ci [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit ci --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--date, -d DATE"
    printf "    Set commit date in YYYY-MM-DD format (must be used with --time)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--time, -t TIME"
    printf "    Set commit time in HH:MM:SS format (must be used with --date)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit ci\n"
    printf "  [Result]\n"
    printf "  - git commit -m \"ci: \" --edit\n"
    printf "  - * Open default editor to complete the message *\n"
    echo

  fi
}

# :command.usage
sgit_docs_usage() {
  printf "sgit docs - Documentation only changes\n\n"
  printf "Alias: dc\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit docs [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit docs --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--date, -d DATE"
    printf "    Set commit date in YYYY-MM-DD format (must be used with --time)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--time, -t TIME"
    printf "    Set commit time in HH:MM:SS format (must be used with --date)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit docs \"update per tech review\" -Apfe\n"
    printf "  [Result]\n"
    printf "  - git add --all\n"
    printf "  - git commit -m \"docs: update per tech review\" --edit\n"
    printf "  - * Open default editor to complete the message *\n"
    printf "  - git push --force\n"
    echo

  fi
}

# :command.usage
sgit_feat_usage() {
  printf "sgit feat - New feature\n\n"
  printf "Alias: ft\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit feat [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit feat --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--date, -d DATE"
    printf "    Set commit date in YYYY-MM-DD format (must be used with --time)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--time, -t TIME"
    printf "    Set commit time in HH:MM:SS format (must be used with --date)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit feat -s \"service-worker\" \"expose more version update events\" -bea \"-p\n  src/index.ts\"\n"
    printf "  [Result]\n"
    printf "  - git add -p src/index.ts\n"
    printf "  - git commit -m \"feat(service-worker)!: expose more version update events\"\n  --edit\n"
    printf "  - * Open default editor to complete the message *\n"
    echo

  fi
}

# :command.usage
sgit_fix_usage() {
  printf "sgit fix - Bug fix\n\n"

  printf "%s\n" "Usage:"
  printf "  sgit fix [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit fix --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--date, -d DATE"
    printf "    Set commit date in YYYY-MM-DD format (must be used with --time)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--time, -t TIME"
    printf "    Set commit time in HH:MM:SS format (must be used with --date)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit fix \"clear service worker cache in safety worker\" -Aps \"service-worker\"\n"
    printf "  [Result]\n"
    printf "  - git add --all\n"
    printf "  - git commit -m \"fix(service-worker): clear service worker cache in safety\n  worker\"\n"
    printf "  - git push\n"
    echo

  fi
}

# :command.usage
sgit_localize_usage() {
  printf "sgit localize - Translations update\n\n"
  printf "Alias: lc\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit localize [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit localize --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--date, -d DATE"
    printf "    Set commit date in YYYY-MM-DD format (must be used with --time)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--time, -t TIME"
    printf "    Set commit time in HH:MM:SS format (must be used with --date)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit localize \"add new en_US terms\" --add-all\n"
    printf "  [Result]\n"
    printf "  - git add --all\n"
    printf "  - git commit -m \"localize: add new us_en terms\"\n"
    echo

  fi
}

# :command.usage
sgit_perf_usage() {
  printf "sgit perf - Code change that improves performance\n\n"
  printf "Alias: pf\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit perf [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit perf --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--date, -d DATE"
    printf "    Set commit date in YYYY-MM-DD format (must be used with --time)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--time, -t TIME"
    printf "    Set commit time in HH:MM:SS format (must be used with --date)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit perf \"add js-web-frameworks benchmark (#34034)\" -pa\n  \"/benchmarks/BUILD.bazel /benchmarks/perf.spec.ts\"\n"
    printf "  [Result]\n"
    printf "  - git add /benchmarks/BUILD.bazel /benchmarks/perf.spec.ts\n"
    printf "  - git commit -m \"perf: add js-web-frameworks benchmark (#34034)\"\n"
    printf "  - git push\n"
    echo

  fi
}

# :command.usage
sgit_refactor_usage() {
  printf "sgit refactor - Code change that neither fixes a bug nor adds a feature; refactoring production code, eg. renaming a variable\n\n"
  printf "Alias: rf\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit refactor [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit refactor --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--date, -d DATE"
    printf "    Set commit date in YYYY-MM-DD format (must be used with --time)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--time, -t TIME"
    printf "    Set commit time in HH:MM:SS format (must be used with --date)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit refactor \"allow to extend other configs\" -A\n"
    printf "  [Result]\n"
    printf "  - git add --all\n"
    printf "  - git commit -m \"refactor: remove ɵloc and related code\"\n"
    echo

  fi
}

# :command.usage
sgit_revert_usage() {
  printf "sgit revert - Reverts a previous commit\n\n"
  printf "Alias: rv\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit revert [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit revert --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--date, -d DATE"
    printf "    Set commit date in YYYY-MM-DD format (must be used with --time)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--time, -t TIME"
    printf "    Set commit time in HH:MM:SS format (must be used with --date)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit revert \"\`refactor(router): clean up internal hooks (#43804)\` (#43845)\"\n"
    printf "  [Result]\n"
    printf "  - git commit -m \"revert: \`refactor(router): clean up internal hooks (#43804)\`\n  (#43845)\"\n"
    echo

  fi
}

# :command.usage
sgit_style_usage() {
  printf "sgit style - Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)\n\n"
  printf "Alias: st\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit style [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit style --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--date, -d DATE"
    printf "    Set commit date in YYYY-MM-DD format (must be used with --time)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--time, -t TIME"
    printf "    Set commit time in HH:MM:SS format (must be used with --date)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit style \"lint panel component\" -p\n"
    printf "  [Result]\n"
    printf "  - git commit -m \"style: lint panel component\"\n"
    printf "  - git push\n"
    echo

  fi
}

# :command.usage
sgit_test_usage() {
  printf "sgit test - Adding missing tests or correcting existing tests\n\n"
  printf "Alias: ts\n"
  echo

  printf "%s\n" "Usage:"
  printf "  sgit test [DESCRIPTION] [OPTIONS]\n"
  printf "  sgit test --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--scope, -s SCOPE"
    printf "    Provides a scope consisting of a noun to provide additional contextual\n    information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--breaking-change, -b"
    printf "    Draw attention to breaking change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--edit, -e"
    printf "    Open default editor to complete commit description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add, -a ADD"
    printf "    Add specific untracked, modified and deleted file to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--add-all, -A"
    printf "    Add all untracked, modified and deleted files to this commit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--put, -p"
    printf "    Put this commit directly on the remote branch\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    If pushed, overwrite existing commits in case conflicts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--date, -d DATE"
    printf "    Set commit date in YYYY-MM-DD format (must be used with --time)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--time, -t TIME"
    printf "    Set commit time in HH:MM:SS format (must be used with --date)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DESCRIPTION"
    printf "    The description is a short summary of the code changes\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  [Command]\n"
    printf "  - sgit test \"remove \`document-register-element\` from elements tests\" -Ap\n"
    printf "  [Result]\n"
    printf "  - git add --all\n"
    printf "  - git commit -m \"test: remove \`document-register-element\` from elements tests\"\n"
    printf "  - git push\n"
    echo

  fi
}

# :command.usage
sgit_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "sgit completions\n\n"
    printf "  Generate bash completions\n  Usage: eval \"\$(cli completions)\"\n\n"
  else
    printf "sgit completions - Generate bash completions\n\n"
  fi

  printf "%s\n" "Usage:"
  printf "  sgit completions\n"
  printf "  sgit completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/handle_custom_date.sh
#!/usr/bin/env bash

# [@bashly-upgrade lib handle_custom_date]
handle_custom_date() {
  local date_flag="${args[--date]}"
  local time_flag="${args[--time]}"

  # Check if only one flag is provided
  if [[ (-n "$date_flag" && -z "$time_flag") || (-z "$date_flag" && -n "$time_flag") ]]; then
    echo "Error: Both --date and --time flags must be used together."
    echo "Usage: --date YYYY-MM-DD --time HH:MM:SS"
    exit 1
  fi

  # If neither flag is provided, return normally
  if [[ -z "$date_flag" && -z "$time_flag" ]]; then
    return 0
  fi

  # Validate date format (YYYY-MM-DD)
  if [[ ! "$date_flag" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
    echo "Error: Invalid date format. Expected format: YYYY-MM-DD"
    echo "Example: --date 2025-07-02"
    exit 1
  fi

  # Validate time format (HH:MM:SS)
  if [[ ! "$time_flag" =~ ^[0-9]{2}:[0-9]{2}:[0-9]{2}$ ]]; then
    echo "Error: Invalid time format. Expected format: HH:MM:SS"
    echo "Example: --time 20:20:18"
    exit 1
  fi

  # Validate date values
  local year month day
  IFS='-' read -r year month day <<< "$date_flag"

  if [[ $month -lt 1 || $month -gt 12 ]]; then
    echo "Error: Invalid month. Month must be between 01-12"
    exit 1
  fi

  if [[ $day -lt 1 || $day -gt 31 ]]; then
    echo "Error: Invalid day. Day must be between 01-31"
    exit 1
  fi

  # Validate time values
  local hour minute second
  IFS=':' read -r hour minute second <<< "$time_flag"

  if [[ $hour -lt 0 || $hour -gt 23 ]]; then
    echo "Error: Invalid hour. Hour must be between 00-23"
    exit 1
  fi

  if [[ $minute -lt 0 || $minute -gt 59 ]]; then
    echo "Error: Invalid minute. Minute must be between 00-59"
    exit 1
  fi

  if [[ $second -lt 0 || $second -gt 59 ]]; then
    echo "Error: Invalid second. Second must be between 00-59"
    exit 1
  fi

  # Create the full datetime string in ISO 8601 format
  local datetime="${date_flag}T${time_flag}"

  # Set environment variables for git
  export GIT_COMMITTER_DATE="$datetime"
  export GIT_AUTHOR_DATE="$datetime"

  return 0
}

# src/lib/send_completions.sh
# [@bashly-upgrade completions send_completions]
send_completions() {
  echo $'#!/usr/bin/env bash'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $'_sgit_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local comp_line="${COMP_WORDS[*]:1}"'
  echo $''
  echo $'  case "$comp_line" in'
  echo $'    \'completions\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'rollback\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'localize\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'refactor\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'revert\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'status\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'mkdir\'*) COMPREPLY=($(compgen -W "--bugfix --build --dev --experimental --feature --help --hotfix --main --merge --only-origin --origin --release --staging --test -H -O -b -d -e -f -h -m -o -r -s -t" -- "$cur")) ;;'
  echo $'    \'style\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'amend\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'chore\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'build\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'docs\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'perf\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'feat\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'wipe\'*) COMPREPLY=($(compgen -W "$(git branch 2> /dev/null) --help --yes -h -y" -- "$cur")) ;;'
  echo $'    \'save\'*) COMPREPLY=($(compgen -W "--global --help -g -h" -- "$cur")) ;;'
  echo $'    \'test\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'edit\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'log\'*) COMPREPLY=($(compgen -W "--author --exclude --help --since --until -a -e -h -s -u" -- "$cur")) ;;'
  echo $'    \'add\'*) COMPREPLY=($(compgen -A directory -A file -W "--help -h" -- "$cur")) ;;'
  echo $'    \'tag\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'put\'*) COMPREPLY=($(compgen -W "$(git branch 2> /dev/null) --force --help -f -h" -- "$cur")) ;;'
  echo $'    \'get\'*) COMPREPLY=($(compgen -W "$(git branch 2> /dev/null) --force --help -f -h" -- "$cur")) ;;'
  echo $'    \'fix\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'sub\'*) COMPREPLY=($(compgen -A directory -A file -W "--all --help -a -h" -- "$cur")) ;;'
  echo $'    \'ci\'*) COMPREPLY=($(compgen -A directory -A file -W "--add --add-all --breaking-change --edit --force --help --put --scope -A -a -b -e -f -h -p -s" -- "$cur")) ;;'
  echo $'    \'rm\'*) COMPREPLY=($(compgen -W "$(git branch 2> /dev/null) --help --only-origin --origin -O -h -o" -- "$cur")) ;;'
  echo $'    \'mv\'*) COMPREPLY=($(compgen -W "$(git branch 2> /dev/null) --help --only-origin --origin -O -h -o" -- "$cur")) ;;'
  echo $'    \'ls\'*) COMPREPLY=($(compgen -W "--help --local --remote -h -l -r" -- "$cur")) ;;'
  echo $'    \'cd\'*) COMPREPLY=($(compgen -W "$(git branch 2> /dev/null) --help -h" -- "$cur")) ;;'
  echo $'    \'\'*) COMPREPLY=($(compgen -W "--help --version -h -v add amend build cd chore ci completions docs edit feat fix get localize log ls mkdir mv perf put refactor revert rm rollback save status style sub tag test wipe" -- "$cur")) ;;'
  echo $'  esac'
  echo $'}'
  echo $''
  echo $'complete -F _sgit_completions sgit'
}

# :command.command_functions
# :command.function
sgit_ls_command() {

  # src/ls_command.sh
  if [ ! -z ${args[--local]} ]; then
    git branch -l | grep -v ‘remotes’
  elif [ ! -z ${args[--remote]} ]; then
    git branch -r | grep -v ‘remotes’
  else
    git branch -a | grep -v ‘remotes’
  fi

}

# :command.function
sgit_take_command() {

  # src/take_command.sh
  if [ ! -z "${args['description']}" ]; then
    branch=${args['description']}
  elif [ ! -z "${args['--main']}" ]; then
    branch=main
  elif [ ! -z "${args['--staging']}" ]; then
    branch=staged
  elif [ ! -z "${args['--test']}" ]; then
    branch=test
  elif [ ! -z "${args['--dev']}" ]; then
    branch=develop
  elif [ ! -z "${args['--feature']}" ]; then
    branch=feature/${args['--feature']}
  elif [ ! -z "${args['--bugfix']}" ]; then
    branch=bugfix/${args['--bugfix']}
  elif [ ! -z "${args['--hotfix']}" ]; then
    branch=hotfix/${args['--hotfix']}
  elif [ ! -z "${args['--experimental']}" ]; then
    branch=experimental/${args['--experimental']}
  elif [ ! -z "${args['--build']}" ]; then
    branch=build/${args['--build']}
  elif [ ! -z "${args['--release']}" ]; then
    branch=release/${args['--release']}
  elif [ ! -z "${args['--merge']}" ]; then
    branch=merge/${args['--merge']}
  fi

  branch=${branch// /-}

  if [ ! -z ${args['--only-origin']} ]; then
    git push -u origin $branch
  elif [ ! -z ${args['--origin']} ]; then
    git checkout -b $branch
    git push -u origin $branch
  else
    git checkout -b $branch
  fi
}

# :command.function
sgit_cd_command() {

  # src/cd_command.sh
  git checkout ${args[branch]}

}

# :command.function
sgit_mv_command() {

  # src/mv_command.sh
  if [ ! -z ${args[--only-origin]} ]; then
    git push origin origin/${args[old_branch]}:refs/heads/${args[new_branch]} :${args[old_branch]}
  elif [ ! -z ${args[--origin]} ]; then
    git branch -m ${args[old_branch]} ${args[new_branch]}
    git push origin origin/${args[old_branch]}:refs/heads/${args[new_branch]} :${args[old_branch]}
  else
    git branch -m ${args[old_branch]} ${args[new_branch]}
  fi

}

# :command.function
sgit_rm_command() {

  # src/rm_command.sh
  if [ ! -z ${args[--only-origin]} ]; then
    git push origin --delete ${args[branch]}
  else
    if [ ${args[branch]} == "$(git branch --show-current)" ]; then
      branches=$(git branch -l)
      IFS=$'\n'
      branches=($branches)
      current_branch=$(git rev-parse --abbrev-ref HEAD)
      jump_branch=$([[ "*$current_branch" == "${branches[0]// /}" ]] && echo "${branches[1]// /}" || echo "${branches[0]// /}")
      git checkout $jump_branch
    fi
    git branch -D ${args[branch]}
    if [ ! -z ${args[--origin]} ]; then
      git push origin --delete ${args[branch]}
    fi
  fi

}

# :command.function
sgit_save_command() {

  # src/save_command.sh
  if [ ! -z ${args[--global]} ]; then
    git config --global credential.helper store
  else
    git config credential.helper store
  fi

}

# :command.function
sgit_remote_command() {

  # src/remote_command.sh
  if [ ! -z "${args[--add]}" ]; then # Add or replace the current origin remote repository"
    git remote rm origin
    git remote add origin ${args[--add]}
  fi

  if [ ! -z "${args[--add-all]}" ]; then # Add or replace the current origin remote repository"
    git remote rm origin
    git remote add origin ${args[--add-all]}
  fi

  git remote -v | awk '{print $2}' | sort -u

}

# :command.function
sgit_wipe_command() {

  # src/wipe_command.sh
  branch=$([[ ! -z "${args[branch]}" ]] && echo ${args[branch]} || echo $(git rev-parse --abbrev-ref HEAD))

  if [ ! -z ${args[--yes]} ]; then
    git reset --hard origin/$branch
  else
    echo "Are you sure you want to wipe (hard reset) \"$branch\" branch? (y/N)"
    read REPLY
    if [[ "$REPLY" =~ ^[Yy]$ ]]; then
      git reset --hard origin/$branch
    fi
  fi

}

# :command.function
sgit_rollback_command() {

  # src/rollback_command.sh
  if [ ! -z ${args[commit_id]} ]; then
    git reset --soft ${args[commit_id]}
  else
    git reset --soft HEAD~1
  fi
  git reset
}

# :command.function
sgit_edit_command() {

  # src/edit_command.sh
  if [ -z ${args[commit_id]} ]; then
    git commit --amend
  else
    HEAD_COMMIT=$(git rev-list HEAD | nl | grep ${args[commit_id]})
    read HEAD_ID _ <<<"$HEAD_COMMIT"

    echo "==========================="
    echo
    echo "ATTENTION! Alter \"pick\" to \"reword\" in the commit you want to edit."
    echo "After that, save and close the file, so you will be able to edit the commit message."
    echo ""
    echo "To publish you must run \"git put --force\"."
    echo "This is NOT RECOMMENDED if commits have already been made to a remote repository and other collaborators are active."
    echo
    echo "==========================="

    git rebase -i HEAD~$HEAD_ID

  fi
}

# :command.function
sgit_get_command() {

  # src/get_command.sh
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")
  branch=$([[ ! -z "${args[branch]}" ]] && echo ${args[branch]} || echo $(git rev-parse --abbrev-ref HEAD))

  git pull $force origin $branch

}

# :command.function
sgit_put_command() {

  # src/put_command.sh
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")
  branch=$([[ ! -z "${args[branch]}" ]] && echo ${args[branch]} || echo $(git rev-parse --abbrev-ref HEAD))

  git push $force origin $branch

}

# :command.function
sgit_log_command() {

  # src/log_command.sh
  query+=$([[ ! -z "${args[search_terms]}" ]] && echo "--grep ${args[search_terms]} " || echo "")
  query+=$([[ ! -z "${args[--author]}" ]] && echo "--author ${args[--author]} " || echo "")
  query+=$([[ ! -z "${args[--since]}" ]] && echo "--since ${args[--since]} " || echo "")
  query+=$([[ ! -z "${args[--until]}" ]] && echo "--until ${args[--until]} " || echo "")
  query+=$([[ ! -z "${args[--exclude]}" ]] && echo "--invert-grep " || echo "")

  git log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %C(green)(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit $query
}

# :command.function
sgit_status_command() {

  # src/status_command.sh
  git status -s

}

# :command.function
sgit_incoming_command() {

  # src/incoming_command.sh
  # Show the incoming commits from remote branch that is not in the working branch
  git fetch origin --quiet
  git log --oneline --no-merges --left-only --cherry-pick --decorate --pretty=format:"%C(yellow)%h %Cgreen%cr %Cblue%an%Creset %s" $(git rev-parse --abbrev-ref HEAD)..origin/$(git rev-parse --abbrev-ref HEAD)

}

# :command.function
sgit_outgoing_command() {

  # src/outgoing_command.sh
  # Show the outgoing commits from working branch that is not in the remote branch
  git fetch origin --quiet
  git log --oneline --no-merges --right-only --cherry-pick --decorate --pretty=format:"%C(yellow)%h %Cgreen%cr %Cblue%an%Creset %s" origin/$(git rev-parse --abbrev-ref HEAD)..$(git rev-parse --abbrev-ref HEAD)

}

# :command.function
sgit_committers_command() {

  # src/committers_command.sh
  git log | grep Author | sort | uniq -c | sort -n -r

}

# :command.function
sgit_add_command() {

  # src/add_command.sh
  git add ${other_args[*]}
}

# :command.function
sgit_sub_command() {

  # src/sub_command.sh
  if [ ! -z "${args[--all]}" ]; then
    git reset
  else
    git restore --staged ${other_args[*]}
  fi

}

# :command.function
sgit_amend_command() {

  # src/amend_command.sh
  # Handle custom date/time if provided
  handle_custom_date

  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit --amend --no-edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_resolve_command() {

  # src/resolve_command.sh
  if [ ! -z "${args[--ours]}" ]; then # Resolve conflicts using the working branch version"
    git checkout --ours .
  fi

  if [ ! -z "${args[--theirs]}" ]; then # Resolve conflicts using the remote branch version"
    git checkout --theirs .
  fi

}

# :command.function
sgit_tag_command() {

  # src/tag_command.sh
  git config --global push.followTags true
  git tag -a ${args[message]} -m ${args[message]}
}

# :command.function
sgit_commit_command() {

  # src/commit_command.sh
  API_URL="https://ai.kuch.workers.dev/api/v1/generate-commit"

  # Handle custom date/time if provided
  handle_custom_date

  edit=$([[ (! -z "${args[description]}") && (-z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  # Check if the description is empty
  if [ -z "${args[description]}" ]; then
    echo "Error: The description is required."
    exit 1
  fi

  while true; do
    # Request the commit message
    json_data='{"description": "'${args[description]}'"}'
    response=$(curl -s -X POST -H "Content-Type: application/json" -d "$json_data" "$API_URL")

    # Parse the json response and get the commits array without using external tools
    commits=$(echo "$response" | sed -n 's/.*"commits":\[\(.*\)\].*/\1/p')

    # Convert the commits string to an array
    IFS='"' read -r -a commits <<<"$commits"

    # Filter the commits array to remove empty elements
    filtered_array=()
    for value in "${commits[@]}"; do
      if [ ${#value} -ge 10 ]; then
        filtered_array+=("$value")
      fi
    done

    # Show the commit messages options
    echo "Select a commit message:"
    echo ""
    echo "----------"
    echo ""
    for ((i = 0; i < ${#filtered_array[@]}; i += 1)); do
      echo "$((i + 1)). ${filtered_array[i]}" | awk '{gsub(/\\n\\n|\r\n\r\n/,"\n\n")}1'
      echo ""
      echo "----------"
      echo ""
    done

    echo "4. Generate more commit messages"
    echo ""
    echo "----------"
    echo ""

    # Ask the user to enter the number of the commit message
    read -p "Enter the number of the commit message (CTRL+C to exit): " commit_number

    # Chech if the number is valid (between 1 and 4)
    if [[ ! $commit_number =~ ^[1-4]$ ]]; then
      echo "Error: The number is invalid."
      exit 1
    fi

    # Verify if number is 4 to generate another commit message
    if [ $commit_number -eq 4 ]; then
      clear
      continue
    fi

    # Get the selected commit message should awk to remove the new lines
    selected_commit=$(echo "${filtered_array[$((commit_number - 1))]}" | awk '{gsub(/\\n\\n|\r\n\r\n/,"\n\n")}1')

    break
  done

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$selected_commit" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_build_command() {

  # src/build_command.sh
  # Handle custom date/time if provided
  handle_custom_date

  type=build
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_chore_command() {

  # src/chore_command.sh
  # Handle custom date/time if provided
  handle_custom_date

  type=chore
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_ci_command() {

  # src/ci_command.sh
  # Handle custom date/time if provided
  handle_custom_date

  type=ci
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_docs_command() {

  # src/docs_command.sh
  # Handle custom date/time if provided
  handle_custom_date

  type=docs
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_feat_command() {

  # src/feat_command.sh
  # Handle custom date/time if provided
  handle_custom_date

  type=feat
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_fix_command() {

  # src/fix_command.sh
  # Handle custom date/time if provided
  handle_custom_date

  type=fix
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_localize_command() {

  # src/localize_command.sh
  # Handle custom date/time if provided
  handle_custom_date

  type=localize
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_perf_command() {

  # src/perf_command.sh
  # Handle custom date/time if provided
  handle_custom_date

  type=perf
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_refactor_command() {

  # src/refactor_command.sh
  # Handle custom date/time if provided
  handle_custom_date

  type=refactor
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_revert_command() {

  # src/revert_command.sh
  # Handle custom date/time if provided
  handle_custom_date

  type=revert
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_style_command() {

  # src/style_command.sh
  # Handle custom date/time if provided
  handle_custom_date

  type=style
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_test_command() {

  # src/test_command.sh
  # Handle custom date/time if provided
  handle_custom_date

  type=test
  scope=$([[ ! -z "${args[--scope]}" ]] && echo "(${args[--scope]})" || echo "")
  breaking_change=$([[ ! -z "${args[--breaking-change]}" ]] && echo "!" || echo "")
  message="$type$scope$breaking_change: ${args[description]}"
  edit=$([[ ( ! -z "${args[description]}") && ( -z "${args[--edit]}") ]] && echo "" || echo "--edit")
  force=$([[ ! -z "${args[--force]}" ]] && echo "--force" || echo "")

  if [ ! -z ${args[--add-all]} ]; then
    git add --all
  elif [ ! -z "${args[--add]}" ]; then
    git add ${args[--add]}
  fi

  git commit -m "$message" $edit

  if [ ! -z ${args[--put]} ]; then
    git push $force origin $(git rev-parse --abbrev-ref HEAD)
  fi

}

# :command.function
sgit_completions_command() {

  # src/completions_command.sh
  # Call the `send_completions` function which was added by running:
  #
  #   $ bashly add comp function
  #
  # Users can now enable bash completion for this script by running:
  #
  #   $ eval "$(sgit completions)"
  #
  send_completions
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        sgit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    ls)
      action="ls"
      shift
      sgit_ls_parse_requirements "$@"
      shift $#
      ;;

    take | mkdir)
      action="take"
      shift
      sgit_take_parse_requirements "$@"
      shift $#
      ;;

    cd)
      action="cd"
      shift
      sgit_cd_parse_requirements "$@"
      shift $#
      ;;

    mv)
      action="mv"
      shift
      sgit_mv_parse_requirements "$@"
      shift $#
      ;;

    rm)
      action="rm"
      shift
      sgit_rm_parse_requirements "$@"
      shift $#
      ;;

    save)
      action="save"
      shift
      sgit_save_parse_requirements "$@"
      shift $#
      ;;

    remote)
      action="remote"
      shift
      sgit_remote_parse_requirements "$@"
      shift $#
      ;;

    wipe)
      action="wipe"
      shift
      sgit_wipe_parse_requirements "$@"
      shift $#
      ;;

    rollback | rb)
      action="rollback"
      shift
      sgit_rollback_parse_requirements "$@"
      shift $#
      ;;

    edit)
      action="edit"
      shift
      sgit_edit_parse_requirements "$@"
      shift $#
      ;;

    get)
      action="get"
      shift
      sgit_get_parse_requirements "$@"
      shift $#
      ;;

    put)
      action="put"
      shift
      sgit_put_parse_requirements "$@"
      shift $#
      ;;

    log | l)
      action="log"
      shift
      sgit_log_parse_requirements "$@"
      shift $#
      ;;

    status | s)
      action="status"
      shift
      sgit_status_parse_requirements "$@"
      shift $#
      ;;

    incoming | in)
      action="incoming"
      shift
      sgit_incoming_parse_requirements "$@"
      shift $#
      ;;

    outgoing | out)
      action="outgoing"
      shift
      sgit_outgoing_parse_requirements "$@"
      shift $#
      ;;

    committers | cm)
      action="committers"
      shift
      sgit_committers_parse_requirements "$@"
      shift $#
      ;;

    add)
      action="add"
      shift
      sgit_add_parse_requirements "$@"
      shift $#
      ;;

    sub)
      action="sub"
      shift
      sgit_sub_parse_requirements "$@"
      shift $#
      ;;

    amend)
      action="amend"
      shift
      sgit_amend_parse_requirements "$@"
      shift $#
      ;;

    resolve)
      action="resolve"
      shift
      sgit_resolve_parse_requirements "$@"
      shift $#
      ;;

    tag | t)
      action="tag"
      shift
      sgit_tag_parse_requirements "$@"
      shift $#
      ;;

    commit | c)
      action="commit"
      shift
      sgit_commit_parse_requirements "$@"
      shift $#
      ;;

    build | bd)
      action="build"
      shift
      sgit_build_parse_requirements "$@"
      shift $#
      ;;

    chore | ch)
      action="chore"
      shift
      sgit_chore_parse_requirements "$@"
      shift $#
      ;;

    ci)
      action="ci"
      shift
      sgit_ci_parse_requirements "$@"
      shift $#
      ;;

    docs | dc)
      action="docs"
      shift
      sgit_docs_parse_requirements "$@"
      shift $#
      ;;

    feat | ft)
      action="feat"
      shift
      sgit_feat_parse_requirements "$@"
      shift $#
      ;;

    fix)
      action="fix"
      shift
      sgit_fix_parse_requirements "$@"
      shift $#
      ;;

    localize | lc)
      action="localize"
      shift
      sgit_localize_parse_requirements "$@"
      shift $#
      ;;

    perf | pf)
      action="perf"
      shift
      sgit_perf_parse_requirements "$@"
      shift $#
      ;;

    refactor | rf)
      action="refactor"
      shift
      sgit_refactor_parse_requirements "$@"
      shift $#
      ;;

    revert | rv)
      action="revert"
      shift
      sgit_revert_parse_requirements "$@"
      shift $#
      ;;

    style | st)
      action="style"
      shift
      sgit_style_parse_requirements "$@"
      shift $#
      ;;

    test | ts)
      action="test"
      shift
      sgit_test_parse_requirements "$@"
      shift $#
      ;;

    completions)
      action="completions"
      shift
      sgit_completions_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      sgit_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_ls_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_ls_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="ls"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --remote | -r)

        # :flag.case_no_arg
        args['--remote']=1
        shift
        ;;

      # :flag.case
      --local | -l)

        # :flag.case_no_arg
        args['--local']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_take_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_take_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="take"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --origin | -o)

        # :flag.case_no_arg
        args['--origin']=1
        shift
        ;;

      # :flag.case
      --only-origin | -O)

        # :flag.case_no_arg
        args['--only-origin']=1
        shift
        ;;

      # :flag.case
      --main)

        # :flag.case_no_arg
        args['--main']=1
        shift
        ;;

      # :flag.case
      --staging | -s)

        # :flag.case_no_arg
        args['--staging']=1
        shift
        ;;

      # :flag.case
      --test | -t)

        # :flag.case_no_arg
        args['--test']=1
        shift
        ;;

      # :flag.case
      --dev | -d)

        # :flag.case_no_arg
        args['--dev']=1
        shift
        ;;

      # :flag.case
      --feature | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--feature']="$2"
          shift
          shift
        else
          printf "%s\n" "--feature requires an argument: --feature, -f DESCRIPTION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --bugfix | -b)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--bugfix']="$2"
          shift
          shift
        else
          printf "%s\n" "--bugfix requires an argument: --bugfix, -b DESCRIPTION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --hotfix | -H)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--hotfix']="$2"
          shift
          shift
        else
          printf "%s\n" "--hotfix requires an argument: --hotfix, -H DESCRIPTION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --experimental | -e)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--experimental']="$2"
          shift
          shift
        else
          printf "%s\n" "--experimental requires an argument: --experimental, -e DESCRIPTION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --build | -u)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--build']="$2"
          shift
          shift
        else
          printf "%s\n" "--build requires an argument: --build, -u DESCRIPTION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --release | -r)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--release']="$2"
          shift
          shift
        else
          printf "%s\n" "--release requires an argument: --release, -r DESCRIPTION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --merge | -m)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--merge']="$2"
          shift
          shift
        else
          printf "%s\n" "--merge requires an argument: --merge, -m DESCRIPTION" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['description']+x} ]]; then
          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_cd_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_cd_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="cd"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['branch']+x} ]]; then
          args['branch']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['branch']+x} ]]; then
    printf "missing required argument: BRANCH\nusage: sgit cd BRANCH\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
sgit_mv_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_mv_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="mv"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --origin | -o)

        # :flag.case_no_arg
        args['--origin']=1
        shift
        ;;

      # :flag.case
      --only-origin | -O)

        # :flag.case_no_arg
        args['--only-origin']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['old_branch']+x} ]]; then
          args['old_branch']=$1
          shift
        # :argument.case
        elif [[ -z ${args['new_branch']+x} ]]; then
          args['new_branch']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['old_branch']+x} ]]; then
    printf "missing required argument: OLD_BRANCH\nusage: sgit mv OLD_BRANCH NEW_BRANCH [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['new_branch']+x} ]]; then
    printf "missing required argument: NEW_BRANCH\nusage: sgit mv OLD_BRANCH NEW_BRANCH [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
sgit_rm_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_rm_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="rm"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --origin | -o)

        # :flag.case_no_arg
        args['--origin']=1
        shift
        ;;

      # :flag.case
      --only-origin | -O)

        # :flag.case_no_arg
        args['--only-origin']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['branch']+x} ]]; then
          args['branch']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_save_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_save_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="save"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --global | -g)

        # :flag.case_no_arg
        args['--global']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_remote_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_remote_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="remote"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --remove | -r)

        # :flag.case_no_arg
        args['--remove']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_wipe_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_wipe_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="wipe"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --yes | -y)

        # :flag.case_no_arg
        args['--yes']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['branch']+x} ]]; then
          args['branch']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_rollback_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_rollback_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="rollback"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['commit_id']+x} ]]; then
          args['commit_id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_edit_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_edit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="edit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['commit_id']+x} ]]; then
          args['commit_id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_get_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['branch']+x} ]]; then
          args['branch']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_put_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_put_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="put"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['branch']+x} ]]; then
          args['branch']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_log_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_log_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="log"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --author | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--author']="$2"
          shift
          shift
        else
          printf "%s\n" "--author requires an argument: --author, -a AUTHOR" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --since | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--since']="$2"
          shift
          shift
        else
          printf "%s\n" "--since requires an argument: --since, -s SINCE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --until | -u)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--until']="$2"
          shift
          shift
        else
          printf "%s\n" "--until requires an argument: --until, -u UNTIL" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --exclude | -e)

        # :flag.case_no_arg
        args['--exclude']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['search_terms']+x} ]]; then
          args['search_terms']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_incoming_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_incoming_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="incoming"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_outgoing_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_outgoing_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="outgoing"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_committers_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_committers_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="committers"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_add_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="add"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_sub_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_sub_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="sub"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --all | -a)

        # :flag.case_no_arg
        args['--all']=1
        shift
        ;;

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_amend_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_amend_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="amend"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --date | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--date']="$2"
          shift
          shift
        else
          printf "%s\n" "--date requires an argument: --date, -d DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --time | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--time']="$2"
          shift
          shift
        else
          printf "%s\n" "--time requires an argument: --time, -t TIME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_resolve_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_resolve_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="resolve"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ours | -o)

        # :flag.case_no_arg
        args['--ours']=1
        shift
        ;;

      # :flag.case
      --theirs | -t)

        # :flag.case_no_arg
        args['--theirs']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_tag_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_tag_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tag"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['message']+x} ]]; then
          args['message']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_commit_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_commit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="commit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --date | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--date']="$2"
          shift
          shift
        else
          printf "%s\n" "--date requires an argument: --date, -d DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --time | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--time']="$2"
          shift
          shift
        else
          printf "%s\n" "--time requires an argument: --time, -t TIME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['description']+x} ]]; then
          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_build_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_build_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="build"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --date | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--date']="$2"
          shift
          shift
        else
          printf "%s\n" "--date requires an argument: --date, -d DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --time | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--time']="$2"
          shift
          shift
        else
          printf "%s\n" "--time requires an argument: --time, -t TIME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['description']+x} ]]; then
          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_chore_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_chore_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="chore"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --date | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--date']="$2"
          shift
          shift
        else
          printf "%s\n" "--date requires an argument: --date, -d DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --time | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--time']="$2"
          shift
          shift
        else
          printf "%s\n" "--time requires an argument: --time, -t TIME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['description']+x} ]]; then
          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_ci_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_ci_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="ci"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --date | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--date']="$2"
          shift
          shift
        else
          printf "%s\n" "--date requires an argument: --date, -d DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --time | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--time']="$2"
          shift
          shift
        else
          printf "%s\n" "--time requires an argument: --time, -t TIME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['description']+x} ]]; then
          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_docs_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_docs_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="docs"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --date | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--date']="$2"
          shift
          shift
        else
          printf "%s\n" "--date requires an argument: --date, -d DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --time | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--time']="$2"
          shift
          shift
        else
          printf "%s\n" "--time requires an argument: --time, -t TIME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['description']+x} ]]; then
          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_feat_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_feat_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="feat"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --date | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--date']="$2"
          shift
          shift
        else
          printf "%s\n" "--date requires an argument: --date, -d DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --time | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--time']="$2"
          shift
          shift
        else
          printf "%s\n" "--time requires an argument: --time, -t TIME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['description']+x} ]]; then
          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_fix_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_fix_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fix"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --date | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--date']="$2"
          shift
          shift
        else
          printf "%s\n" "--date requires an argument: --date, -d DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --time | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--time']="$2"
          shift
          shift
        else
          printf "%s\n" "--time requires an argument: --time, -t TIME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['description']+x} ]]; then
          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_localize_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_localize_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="localize"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --date | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--date']="$2"
          shift
          shift
        else
          printf "%s\n" "--date requires an argument: --date, -d DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --time | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--time']="$2"
          shift
          shift
        else
          printf "%s\n" "--time requires an argument: --time, -t TIME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['description']+x} ]]; then
          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_perf_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_perf_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="perf"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --date | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--date']="$2"
          shift
          shift
        else
          printf "%s\n" "--date requires an argument: --date, -d DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --time | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--time']="$2"
          shift
          shift
        else
          printf "%s\n" "--time requires an argument: --time, -t TIME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['description']+x} ]]; then
          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_refactor_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_refactor_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="refactor"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --date | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--date']="$2"
          shift
          shift
        else
          printf "%s\n" "--date requires an argument: --date, -d DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --time | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--time']="$2"
          shift
          shift
        else
          printf "%s\n" "--time requires an argument: --time, -t TIME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['description']+x} ]]; then
          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_revert_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_revert_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="revert"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --date | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--date']="$2"
          shift
          shift
        else
          printf "%s\n" "--date requires an argument: --date, -d DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --time | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--time']="$2"
          shift
          shift
        else
          printf "%s\n" "--time requires an argument: --time, -t TIME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['description']+x} ]]; then
          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_style_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_style_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="style"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --date | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--date']="$2"
          shift
          shift
        else
          printf "%s\n" "--date requires an argument: --date, -d DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --time | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--time']="$2"
          shift
          shift
        else
          printf "%s\n" "--time requires an argument: --time, -t TIME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['description']+x} ]]; then
          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_test_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_test_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --scope | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--scope']="$2"
          shift
          shift
        else
          printf "%s\n" "--scope requires an argument: --scope, -s SCOPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --breaking-change | -b)

        # :flag.case_no_arg
        args['--breaking-change']=1
        shift
        ;;

      # :flag.case
      --edit | -e)

        # :flag.case_no_arg
        args['--edit']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--add']="$2"
          shift
          shift
        else
          printf "%s\n" "--add requires an argument: --add, -a ADD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --add-all | -A)

        # :flag.case_no_arg
        args['--add-all']=1
        shift
        ;;

      # :flag.case
      --put | -p)

        # :flag.case_no_arg
        args['--put']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --date | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--date']="$2"
          shift
          shift
        else
          printf "%s\n" "--date requires an argument: --date, -d DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --time | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--time']="$2"
          shift
          shift
        else
          printf "%s\n" "--time requires an argument: --time, -t TIME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['description']+x} ]]; then
          args['description']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
sgit_completions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        sgit_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.2.0"
  set -e

  # src/initialize.sh
  # Code here runs inside the initialize() function
  # Use it for anything that you need to run before any other function, like
  # setting environment vairables:
  # CONFIG_FILE=settings.ini
  #
  # Feel free to empty (but not delete) this file.

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -a other_args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "ls") sgit_ls_command ;;
    "take") sgit_take_command ;;
    "cd") sgit_cd_command ;;
    "mv") sgit_mv_command ;;
    "rm") sgit_rm_command ;;
    "save") sgit_save_command ;;
    "remote") sgit_remote_command ;;
    "wipe") sgit_wipe_command ;;
    "rollback") sgit_rollback_command ;;
    "edit") sgit_edit_command ;;
    "get") sgit_get_command ;;
    "put") sgit_put_command ;;
    "log") sgit_log_command ;;
    "status") sgit_status_command ;;
    "incoming") sgit_incoming_command ;;
    "outgoing") sgit_outgoing_command ;;
    "committers") sgit_committers_command ;;
    "add") sgit_add_command ;;
    "sub") sgit_sub_command ;;
    "amend") sgit_amend_command ;;
    "resolve") sgit_resolve_command ;;
    "tag") sgit_tag_command ;;
    "commit") sgit_commit_command ;;
    "build") sgit_build_command ;;
    "chore") sgit_chore_command ;;
    "ci") sgit_ci_command ;;
    "docs") sgit_docs_command ;;
    "feat") sgit_feat_command ;;
    "fix") sgit_fix_command ;;
    "localize") sgit_localize_command ;;
    "perf") sgit_perf_command ;;
    "refactor") sgit_refactor_command ;;
    "revert") sgit_revert_command ;;
    "style") sgit_style_command ;;
    "test") sgit_test_command ;;
    "completions") sgit_completions_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  initialize
  run "$@"
fi
